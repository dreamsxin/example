# kafka 的队列模型

首先，每个 topic 可以有多个 partition，每个 partition 才是严格意义上的消息队列（消息先进先出），而不同 partition 之间是互不影响的。
举个例子来说，有消息 A 和消息 B，如果要保证 A 一定要比 B 先被消费，就必须要保证 A 一定要先被投递到某个 partition，且 B 再被投递到同一个 partition。
如果 B 被投递到了不一样 partition，那么 B 是有可能先于 A 被消费的。

其次，“一个 topic 的一个 partition”是保证无重复消息的最小消费单元，换句话说，如果有两个消费程序消费同一个 topic 的同一个 partition，那它们消费的消息事实上是彼此重复的。
所以为保证所有 partition 均被消费，且不会被同一个业务（属于同一个 group）的多个消费程序重复消费，是需要一个分配策略来决定每个消费程序应当消费哪几个或哪一个 partition，又或者应当做作为候补（当消费程序数量大于 partition 数量时发生），而 kafka 是希望用户程序自行实现这个分配策略的。

这个看似复杂讨厌的缺陷，个人认为其实是一个特性，这是因为这个特性，kafka 可以应对多样的、复杂的应用场景，直至被玩出花来。举例说明一下。

- 消息没有严格有序性要求，任意消息可以被任意消费程序消费，且消费各消息耗时相近——可以将消息投递到任意 partition，partition 任意均等分配到各个消费程序；
- 所有消息要求严格有序，但消息量不大——可以配置仅一个 partition，一个消费程序负责消费，其他消费程序作为替补；
- 同组消息要求有序，不同组消息不要求有序，例如同一个用户的消费要求有序，不同用户的消息不要求有序——可以将属于同一组的消息投递到同一个 partition，比如拿 UID 对 partition 数量取模；
- 特定组的消息仅可以被特定消费程序消费——可以在将该特定组的消息投递到特定 partition，配置时指定到特定消费程序；
- 某些消息消费耗时长且要求有序，有些消息消费耗时短且不要求有序——可以将分为两组 partition，一组实行针对有序消息的策略，且多一些 partition、多一些消费程序增大处理能力，另一组实行针对无序消息的的策略，且少一些 partition、少一些消费程序节省资源。
