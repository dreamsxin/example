
```sql
CREATE MATERIALIZED view 物化视图名称 as 查询语句 with DATA

## WITH NO DATA
-- Continuous aggregates
-- Define view
CREATE MATERIALIZED VIEW weather_metrics_daily WITH ( timescaledb.continuous ) AS SELECT
time_bucket ( '1 day', TIME ) AS bucket,
city_name,
AVG ( temp_c ) AS avg_temp,
AVG ( feels_like_c ) AS feels_like_temp,
MAX ( temp_c ) AS max_temp,
MIN ( temp_c ) AS min_temp,
AVG ( pressure_hpa ) AS pressure,
AVG ( humidity_percent ) AS humidity_percent,
AVG ( rain_3h_mm ) AS rain_3h,
AVG ( snow_3h_mm ) AS snow_3h,
AVG ( wind_speed_ms ) AS wind_speed,
AVG ( clouds_percent ) AS clouds 
FROM
	weather_metrics 
GROUP BY
	bucket,
	city_name
WITH NO DATA;
### 手动刷新
refresh_continuous_aggregate(物化视图名称, 'sdate', 'edate')
### 自动刷新
-- create policy-- refresh the last 6 months of data every 2 weeks
SELECT add_continuous_aggregate_policy ( 'weather_metrics_daily', start_offset => INTERVAL '6 months', end_offset => INTERVAL '1 hour',   schedule_interval  =>  INTERVAL  '14 days' )
```


## 从聚合查询变为连续聚合

可以通过CREATE MATERIALIZED VIEW命令触发数据库创建具有给定名称的物化视图，（相当于里面是有数据存储的）WITH (timescaledb.continuous)指示 TimescaleDB 创建一个连续的聚合，而不仅仅是一个通用的物化视图。最后，在AS关键字之后添加之前的查询。
```sql
CREATE MATERIALIZED VIEW stock_candlestick_daily
WITH (timescaledb.continuous) AS
SELECT
  time_bucket('1 day', "time") AS day,
  symbol,
  max(price) AS high,
  first(price, time) AS open,
  last(price, time) AS close,
  min(price) AS low
FROM stocks_real_time srt
GROUP BY day, symbol;
```
查询数据的话只需要查询当前视图数据即可
```sql
SELECT * FROM stock_candlestick_daily ORDER BY day DESC, symbol;
```
### 实时连续聚合

默认情况下，所有连续聚合都创建为实时聚合。这意味着 TimescaleDB 会将UNION尚未通过刷新策略具体化的最新数据附加（或）到连续聚合的输出中

使用和设置连续聚合策略：

1、自动连续聚合刷新策略
```sql
--此策略每天运行一次，由 设置schedule_interval。当它运行时，
--它会具体化 3 天前到 1 小时前的数据，由 start_offset和设置end_offset。
--偏移时间是相对于查询执行时间计算的。
--执行的查询是在连续聚合中定义的查询stock_candlestick_daily。
SELECT add_continuous_aggregate_policy('stock_candlestick_daily',
  start_offset => INTERVAL '3 days',
  end_offset => INTERVAL '1 hour',
  schedule_interval => INTERVAL '1 days');
```
2、手动刷新

这在插入或修改超出刷新策略start_offset和end_offset间隔的数据时最有用。这在边缘物联网系统中很常见，其中设备长时间失去互联网连接，并在重新连接后最终发送历史读数。
```sql
--此手动刷新仅更新您的连续聚合一次。它不会自动使聚合保持最新。
--要设置自动刷新策略，请参阅前面关于连续聚合刷新策略的部分。
--当前语句是刷新1周前到当前的数据到连续聚合中
CALL refresh_continuous_aggregate(
  'stock_candlestick_daily',
  now() - INTERVAL '1 week',
  now()
);
```
