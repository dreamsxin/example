以下是基于 TimescaleDB 实现用户行为分析（包括漏斗分析、留存分析及其他常见分析）的详细 SQL 方案，结合时序数据库特性优化计算效率：

---

### 📊 **一、漏斗分析 SQL**  
**目标**：统计用户从“启动→浏览→加购→支付”的转化率（窗口期 7 天）。  
```sql
WITH user_events AS (
  SELECT
    user_id,
    time_bucket('1 day', event_time) AS bucket_day,
    event_type,
    -- 标记每个步骤是否完成
    CASE 
        WHEN event_type = '启动' THEN 1
        WHEN event_type = '浏览' THEN 2
        WHEN event_type = '加购' THEN 3
        WHEN event_type = '支付' THEN 4
    END AS step
  FROM user_behavior
  WHERE event_time >= NOW() - INTERVAL '30 days'
),
step_sequence AS (
  SELECT
    user_id,
    step,
    MIN(bucket_day) AS first_step_day
  FROM user_events
  GROUP BY user_id, step
),
funnel_data AS (
  SELECT
    user_id,
    MAX(CASE WHEN step = 1 THEN first_step_day END) AS step1_day,
    MAX(CASE WHEN step = 2 AND first_step_day <= (MAX(CASE WHEN step = 1 THEN first_step_day END) + INTERVAL '7 days') THEN 1 END) AS step2_flag,
    MAX(CASE WHEN step = 3 AND first_step_day <= (MAX(CASE WHEN step = 1 THEN first_step_day END) + INTERVAL '7 days') THEN 1 END) AS step3_flag,
    MAX(CASE WHEN step = 4 AND first_step_day <= (MAX(CASE WHEN step = 1 THEN first_step_day END) + INTERVAL '7 days') THEN 1 END) AS step4_flag
  FROM step_sequence
  GROUP BY user_id
  HAVING MAX(CASE WHEN step = 1 THEN first_step_day END) IS NOT NULL
)
SELECT
  COUNT(*) AS total_users,
  SUM(step2_flag) AS step2_users,
  SUM(step3_flag) AS step3_users,
  SUM(step4_flag) AS step4_users,
  ROUND(SUM(step2_flag) * 1.0 / COUNT(*), 2) AS step1_to_step2_rate,
  ROUND(SUM(step4_flag) * 1.0 / SUM(step2_flag), 2) AS step2_to_step4_rate
FROM funnel_data;
```

**优化说明**：  
1. **时间分桶**：`time_bucket` 按天聚合事件，减少计算量。  
2. **条件聚合**：通过 `CASE WHEN` 和窗口期约束（`+ INTERVAL '7 days'`）确保步骤顺序。  
3. **避免多重 JOIN**：使用条件标记替代子查询连接，提升性能。

---

### 📈 **二、用户留存分析 SQL**  
**目标**：计算新用户的 1/3/7/30 日留存率。  
```sql
WITH first_actions AS (
  SELECT
    user_id,
    MIN(time_bucket('1 day', event_time)) AS first_day
  FROM user_behavior
  GROUP BY user_id
),
retention_data AS (
  SELECT
    f.user_id,
    f.first_day,
    time_bucket('1 day', u.event_time) AS active_day,
    (EXTRACT(EPOCH FROM (time_bucket('1 day', u.event_time) - f.first_day)) / 86400) AS days_diff
  FROM first_actions f
  JOIN user_behavior u ON f.user_id = u.user_id
  WHERE u.event_time >= f.first_day
)
SELECT
  first_day AS cohort_date,
  COUNT(DISTINCT user_id) AS cohort_size,
  COUNT(DISTINCT CASE WHEN days_diff = 1 THEN user_id END) AS d1_retained,
  COUNT(DISTINCT CASE WHEN days_diff = 3 THEN user_id END) AS d3_retained,
  COUNT(DISTINCT CASE WHEN days_diff = 7 THEN user_id END) AS d7_retained,
  COUNT(DISTINCT CASE WHEN days_diff = 30 THEN user_id END) AS d30_retained,
  ROUND(COUNT(DISTINCT CASE WHEN days_diff = 1 THEN user_id END) * 1.0 / COUNT(DISTINCT user_id), 2) AS d1_retention_rate
FROM retention_data
GROUP BY first_day
ORDER BY first_day DESC;
```

**关键点**：  
1. **首日标记**：通过 `MIN(event_time)` 确定用户首日（cohort）。  
2. **留存窗口**：`days_diff` 计算活跃日与首日的时间差，过滤指定窗口（1/3/7/30天）。  
3. **分群统计**：按首日分组（`cohort_date`），避免新老用户混杂。

---

### ⚡ **三、其他常见行为分析 SQL**  
#### **1. 用户路径分析**  
```sql
SELECT
  user_id,
  array_agg(event_type ORDER BY event_time) AS event_sequence
FROM user_behavior
WHERE event_time >= NOW() - INTERVAL '7 days'
GROUP BY user_id;
```

#### **2. 日活跃用户（DAU）与频次**  
```sql
SELECT
  time_bucket('1 day', event_time) AS day,
  COUNT(DISTINCT user_id) AS dau,
  COUNT(*) AS total_events,
  ROUND(COUNT(*) * 1.0 / COUNT(DISTINCT user_id), 1) AS events_per_user
FROM user_behavior
GROUP BY day
ORDER BY day DESC;
```

#### **3. 用户平均使用时长（Session 分析）**  
```sql
SELECT
  user_id,
  AVG(session_duration) AS avg_session_duration
FROM (
  SELECT
    user_id,
    session_id,
    EXTRACT(EPOCH FROM (MAX(event_time) - MIN(event_time))) AS session_duration
  FROM user_behavior
  GROUP BY user_id, session_id
) sessions
GROUP BY user_id;
```

#### **4. 关键事件转化趋势**  
```sql
SELECT
  time_bucket('1 hour', event_time) AS hour,
  COUNT(*) FILTER (WHERE event_type = '支付') AS payment_count,
  COUNT(*) FILTER (WHERE event_type = '加购') AS cart_count,
  ROUND(COUNT(*) FILTER (WHERE event_type = '支付') * 1.0 / 
        NULLIF(COUNT(*) FILTER (WHERE event_type = '加购'), 0), 2) AS cart_to_payment_rate
FROM user_behavior
GROUP BY hour
ORDER BY hour DESC;
```

---

### ⚙️ **四、TimescaleDB 优化建议**  
1. **Hypertable 分区**：  
   ```sql
   SELECT create_hypertable('user_behavior', 'event_time');
   SELECT set_chunk_time_interval('user_behavior', INTERVAL '7 days'); -- 按周分区
   ```
2. **索引优化**：  
   ```sql
   CREATE INDEX idx_user_time ON user_behavior (user_id, event_time DESC);
   CREATE INDEX idx_event_type ON user_behavior (event_type);
   ```
3. **连续聚合（物化视图）**：  
   ```sql
   CREATE MATERIALIZED VIEW user_daily_summary
   WITH (timescaledb.continuous) AS
   SELECT
     time_bucket('1 day', event_time) AS day,
     user_id,
     COUNT(*) AS events
   FROM user_behavior
   GROUP BY day, user_id;
   ```
4. **数据压缩与保留策略**：  
   ```sql
   ALTER TABLE user_behavior SET (timescaledb.compress, timescaledb.compress_orderby = 'event_time');
   SELECT add_compression_policy('user_behavior', INTERVAL '30 days');
   SELECT add_retention_policy('user_behavior', INTERVAL '365 days');
   ```

---

以上方案充分利用 TimescaleDB 的**时间分桶**、**连续聚合**和**分区管理**特性，显著提升海量用户行为数据的分析效率。实际部署时需根据数据量调整分区间隔（`chunk_time_interval`）和聚合策略。
