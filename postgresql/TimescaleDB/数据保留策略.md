TimescaleDB 提供了自动删除旧数据的机制，以下是几种实现方式：

## 1. **数据保留策略（Retention Policy）**

### 基本设置
```sql
-- 创建保留策略，自动删除超过1年的数据
SELECT add_retention_policy('your_hypertable_name', INTERVAL '1 year');
```

### 查看现有策略
```sql
-- 查看所有保留策略
SELECT * FROM timescaledb_information.jobs;
SELECT * FROM timescaledb_information.job_stats;

-- 查看特定表的策略
SELECT * FROM timescaledb_information.policy_stats;
```

### 移除策略
```sql
-- 如果需要修改或移除策略
SELECT remove_retention_policy('your_hypertable_name');
```

## 2. **配置自动压缩+保留**

```sql
-- 先启用压缩（可选但推荐）
ALTER TABLE your_hypertable_name SET (
    timescaledb.compress,
    timescaledb.compress_orderby = 'time DESC'
);

-- 设置压缩后数据的保留策略
SELECT add_compression_policy('your_hypertable_name', INTERVAL '7 days');
SELECT add_retention_policy('your_hypertable_name', INTERVAL '1 year');
```

## 3. **手动创建定时任务**

如果不需要自动策略，可以创建手动清理：

```sql
-- 手动删除旧数据
DELETE FROM your_hypertable_name 
WHERE time < NOW() - INTERVAL '1 year';

-- 或者使用drop_chunks（更高效）
SELECT drop_chunks(
    'your_hypertable_name',
    older_than => INTERVAL '1 year'
);
```

### 创建定时任务（使用cron）
```bash
# 在crontab中添加
0 2 * * * psql -d your_database -c "SELECT drop_chunks('your_hypertable_name', older_than => INTERVAL '1 year');"
```

## 4. **高级配置示例**

```sql
-- 1. 创建超表
CREATE TABLE sensor_data (
    time TIMESTAMPTZ NOT NULL,
    sensor_id INTEGER,
    value DOUBLE PRECISION
);

SELECT create_hypertable('sensor_data', 'time');

-- 2. 设置保留策略（1年）
SELECT add_retention_policy('sensor_data', INTERVAL '1 year');

-- 3. 可选：调整检查频率（默认1小时）
ALTER SYSTEM SET timescaledb.max_retention_period = '365 days';
ALTER SYSTEM SET timescaledb.retention_check_interval = '1h';

-- 重新加载配置
SELECT pg_reload_conf();
```

## 5. **监控和验证**

```sql
-- 查看将要被删除的数据块
SELECT show_chunks('your_hypertable_name', older_than => INTERVAL '1 year');

-- 查看数据分布
SELECT 
    chunk_name,
    range_start,
    range_end,
    pg_size_pretty(chunk_size) as size
FROM timescaledb_information.chunks 
WHERE hypertable_name = 'your_hypertable_name'
ORDER BY range_start;
```

## 6. **注意事项**

1. **权限要求**：需要具有执行权限的用户
2. **性能影响**：`drop_chunks` 操作是块级别的，比逐行DELETE更高效
3. **时区考虑**：确保时间计算考虑时区
4. **依赖关系**：如果有外键引用，需要先处理
5. **WAL影响**：大量删除会产生WAL日志

## 7. **最佳实践**

```sql
-- 定期检查策略执行情况
SELECT 
    job_id,
    last_run_started_at,
    last_successful_finish,
    total_runs,
    total_successes
FROM timescaledb_information.job_stats
WHERE job_type = 'retention';

-- 如果数据量很大，考虑分批删除
SELECT drop_chunks(
    'your_hypertable_name',
    older_than => INTERVAL '1 year',
    newer_than => INTERVAL '2 years'
);
```

## 8. **Troubleshooting**

如果策略没有执行：
```sql
-- 检查后台工作进程
SELECT * FROM timescaledb_information.job_stats;

-- 手动执行一次
CALL run_job(job_id);

-- 启用/禁用作业
SELECT alter_job(job_id, scheduled => true);
```

