## 1. 修改后的 Nginx 配置文件

```nginx
# nginx.conf
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";
    
    # 共享内存区域，用于存储后端服务器信息
    lua_shared_dict upstream_servers 10m;
    
    # 初始化定时清理任务
    init_worker_by_lua_block {
        local upstream = require "upstream"
        upstream.init_cleanup_timer()
    }
    
    upstream backend {
        server 0.0.0.1; # 占位服务器
        balancer_by_lua_block {
            local upstream = require "upstream"
            upstream.least_conn_balancer()
        }
    }
    
    server {
        listen 80;
        
        # 管理接口 - 添加前缀参数
        location /upstream/add {
            content_by_lua_block {
                local upstream = require "upstream"
                upstream.add_server()
            }
        }
        
        location /upstream/remove {
            content_by_lua_block {
                local upstream = require "upstream"
                upstream.remove_server()
            }
        }
        
        location /upstream/status {
            content_by_lua_block {
                local upstream = require "upstream"
                upstream.get_status()
            }
        }
        
        # 基于前缀的路由
        location ~ ^/([^/]+)/ {
            set $route_prefix $1;
            
            # 移除前缀后转发到后端
            rewrite ^/[^/]+/(.*) /$1 break;
            
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Route-Prefix $route_prefix;
            proxy_connect_timeout   60s;
            proxy_read_timeout      90s;
            proxy_send_timeout      60s;
        }
        
        # 根路径和没有前缀的请求使用默认路由
        location / {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Route-Prefix "default";
            proxy_connect_timeout   60s;
            proxy_read_timeout      90s;
            proxy_send_timeout      60s;
        }
    }
}
```

## 2. 修改后的 Lua 模块

```lua
-- upstream.lua
local cjson = require "cjson"
local balancer = require "ngx.balancer"
local ngx_shared = ngx.shared.upstream_servers

local _M = {}

-- 服务器过期时间（秒）
local SERVER_EXPIRE_TIME = 60
-- 清理间隔（秒）
local CLEANUP_INTERVAL = 10

-- 获取客户端IP
local function get_client_ip()
    local headers = ngx.req.get_headers()
    local ip = headers["X-Real-IP"] or headers["X-Forwarded-For"] or ngx.var.remote_addr
    if type(ip) == "table" then
        ip = ip[1]
    end
    if ip and string.find(ip, ",") then
        ip = string.match(ip, "([^,]+)")
    end
    return ip
end

-- 序列化服务器键（包含前缀）
local function get_server_key(prefix, host, port)
    return prefix .. ":" .. host .. ":" .. port
end

-- 获取路由前缀
local function get_route_prefix()
    local prefix = ngx.var.http_x_route_prefix
    if not prefix or prefix == "" then
        prefix = "default"
    end
    return prefix
end

-- 添加或更新服务器（支持前缀）
function _M.add_server()
    local args = ngx.req.get_uri_args()
    local host = args.host
    local port = tonumber(args.port)
    local prefix = args.prefix or "default"  -- 默认前缀
    
    if not port then
        ngx.status = ngx.HTTP_BAD_REQUEST
        ngx.say('{"error": "port is required"}')
        return
    end
    
    -- 如果host为空，使用客户端IP
    if not host or host == "" then
        host = get_client_ip()
    end
    
    local server_key = get_server_key(prefix, host, port)
    
    -- 获取现有服务器信息或创建新的
    local server_info_str = ngx_shared:get(server_key)
    local server_info
    
    if server_info_str then
        server_info = cjson.decode(server_info_str)
        server_info.last_heartbeat = ngx.now()
        ngx.log(ngx.INFO, "Updated server heartbeat: ", server_key)
    else
        server_info = {
            prefix = prefix,
            host = host,
            port = port,
            conn_count = 0,
            last_heartbeat = ngx.now(),
            created_time = ngx.now()
        }
        ngx.log(ngx.INFO, "Added new server: ", server_key)
    end
    
    -- 保存到共享内存
    local success, err = ngx_shared:set(server_key, cjson.encode(server_info), SERVER_EXPIRE_TIME)
    
    if not success then
        ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
        ngx.say('{"error": "failed to add server: ' .. err .. '"}')
        return
    end
    
    ngx.say('{"success": true, "server": "' .. server_key .. '", "prefix": "' .. prefix .. '"}')
end

-- 移除服务器（支持前缀）
function _M.remove_server()
    local args = ngx.req.get_uri_args()
    local host = args.host
    local port = tonumber(args.port)
    local prefix = args.prefix or "default"
    
    if not port then
        ngx.status = ngx.HTTP_BAD_REQUEST
        ngx.say('{"error": "port is required"}')
        return
    end
    
    if not host or host == "" then
        host = get_client_ip()
    end
    
    local server_key = get_server_key(prefix, host, port)
    local success, err = ngx_shared:delete(server_key)
    
    if not success then
        ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
        ngx.say('{"error": "failed to remove server: ' .. err .. '"}')
        return
    end
    
    ngx.say('{"success": true, "removed": "' .. server_key .. '", "prefix": "' .. prefix .. '"}')
end

-- 获取服务器状态（按前缀分组）
function _M.get_status()
    local groups = {}
    local keys = ngx_shared:get_keys(0)
    
    for _, key in ipairs(keys) do
        local server_info_str = ngx_shared:get(key)
        if server_info_str then
            local server_info = cjson.decode(server_info_str)
            local prefix = server_info.prefix or "default"
            
            if not groups[prefix] then
                groups[prefix] = {
                    prefix = prefix,
                    servers = {}
                }
            end
            
            table.insert(groups[prefix].servers, server_info)
        end
    end
    
    -- 转换为数组格式
    local result = {
        groups = {},
        total_groups = 0,
        total_servers = 0,
        timestamp = ngx.now()
    }
    
    for prefix, group in pairs(groups) do
        table.insert(result.groups, group)
        result.total_groups = result.total_groups + 1
        result.total_servers = result.total_servers + #group.servers
    end
    
    ngx.header["Content-Type"] = "application/json; charset=utf-8"
    ngx.say(cjson.encode(result))
end

-- 最少连接数负载均衡（基于前缀）
function _M.least_conn_balancer()
    local route_prefix = get_route_prefix()
    local least_conn_server = nil
    local least_conn_count = math.huge
    local keys = ngx_shared:get_keys(0)
    
    -- 查找指定前缀中连接数最少的服务器
    for _, key in ipairs(keys) do
        local server_info_str = ngx_shared:get(key)
        if server_info_str then
            local server_info = cjson.decode(server_info_str)
            local server_prefix = server_info.prefix or "default"
            
            -- 只匹配当前路由前缀的服务器
            if server_prefix == route_prefix then
                -- 检查服务器是否过期
                if ngx.now() - server_info.last_heartbeat <= SERVER_EXPIRE_TIME then
                    if server_info.conn_count < least_conn_count then
                        least_conn_count = server_info.conn_count
                        least_conn_server = server_info
                    end
                end
            end
        end
    end
    
    -- 如果没有找到指定前缀的服务器，使用默认前缀
    if not least_conn_server and route_prefix ~= "default" then
        ngx.log(ngx.WARN, "No servers found for prefix: ", route_prefix, ", trying default prefix")
        for _, key in ipairs(keys) do
            local server_info_str = ngx_shared:get(key)
            if server_info_str then
                local server_info = cjson.decode(server_info_str)
                local server_prefix = server_info.prefix or "default"
                
                if server_prefix == "default" then
                    if ngx.now() - server_info.last_heartbeat <= SERVER_EXPIRE_TIME then
                        if server_info.conn_count < least_conn_count then
                            least_conn_count = server_info.conn_count
                            least_conn_server = server_info
                        end
                    end
                end
            end
        end
    end
    
    if not least_conn_server then
        ngx.log(ngx.ERR, "No available servers found for prefix: ", route_prefix)
        return ngx.exit(ngx.HTTP_SERVICE_UNAVAILABLE)
    end
    
    -- 增加连接数
    least_conn_server.conn_count = least_conn_server.conn_count + 1
    local server_key = get_server_key(least_conn_server.prefix or "default", least_conn_server.host, least_conn_server.port)
    ngx_shared:set(server_key, cjson.encode(least_conn_server), SERVER_EXPIRE_TIME)
    
    -- 记录选择的服务器，用于后续减少连接数
    ngx.ctx.selected_server = server_key
    
    -- 设置代理
    local ok, err = balancer.set_current_peer(least_conn_server.host, least_conn_server.port)
    if not ok then
        ngx.log(ngx.ERR, "failed to set current peer: ", err)
        _M.decrease_conn_count(server_key)
        return ngx.exit(ngx.HTTP_SERVICE_UNAVAILABLE)
    end
end

-- 减少连接数（在请求完成后调用）
function _M.decrease_conn_count(server_key)
    local server_info_str = ngx_shared:get(server_key)
    if server_info_str then
        local server_info = cjson.decode(server_info_str)
        if server_info.conn_count > 0 then
            server_info.conn_count = server_info.conn_count - 1
            ngx_shared:set(server_key, cjson.encode(server_info), SERVER_EXPIRE_TIME)
        end
    end
end

-- 清理过期服务器
function _M.cleanup_expired_servers()
    local keys = ngx_shared:get_keys(0)
    local removed_count = 0
    
    for _, key in ipairs(keys) do
        local server_info_str = ngx_shared:get(key)
        if server_info_str then
            local server_info = cjson.decode(server_info_str)
            -- 检查服务器是否过期
            if ngx.now() - server_info.last_heartbeat > SERVER_EXPIRE_TIME then
                ngx_shared:delete(key)
                removed_count = removed_count + 1
                ngx.log(ngx.INFO, "Removed expired server: ", key)
            end
        end
    end
    
    if removed_count > 0 then
        ngx.log(ngx.INFO, "Cleanup removed ", removed_count, " expired servers")
    end
end

-- 初始化定时清理任务
function _M.init_cleanup_timer()
    local handler
    handler = function(premature)
        if premature then
            return
        end
        
        _M.cleanup_expired_servers()
        
        -- 再次设置定时器
        ngx.timer.at(CLEANUP_INTERVAL, handler)
    end
    
    -- 启动定时器
    ngx.timer.at(CLEANUP_INTERVAL, handler)
end

return _M
```

## 3. 修改后的使用示例

### 注册服务器到不同前缀
```bash
# 注册到默认前缀
curl "http://localhost/upstream/add?port=8080"

# 注册到 api 前缀
curl "http://localhost/upstream/add?port=8081&prefix=api"

# 注册到 web 前缀
curl "http://localhost/upstream/add?host=192.168.1.100&port=8080&prefix=web"

# 注册到 admin 前缀
curl "http://localhost/upstream/add?host=192.168.1.101&port=8080&prefix=admin"
```

### 移除指定前缀的服务器
```bash
# 移除默认前缀的服务器
curl "http://localhost/upstream/remove?port=8080"

# 移除 api 前缀的服务器
curl "http://localhost/upstream/remove?port=8081&prefix=api"

# 移除指定主机的服务器
curl "http://localhost/upstream/remove?host=192.168.1.100&port=8080&prefix=web"
```

### 查看状态（按前缀分组）
```bash
curl "http://localhost/upstream/status"
```

### 发送业务请求到不同前缀
```bash
# 默认前缀的请求
curl "http://localhost/api/users"

# api 前缀的请求（会被路由到 api 组的服务器）
curl "http://localhost/api/v1/users"

# web 前缀的请求（会被路由到 web 组的服务器）
curl "http://localhost/web/dashboard"

# admin 前缀的请求（会被路由到 admin 组的服务器）
curl "http://localhost/admin/users"
```

## 4. 主要改进特性

1. **前缀路由功能**：根据 URL 前缀将请求路由到不同的后端服务组
2. **灵活的服务器注册**：可以为不同前缀注册不同的后端服务器
3. **回退机制**：如果指定前缀没有可用服务器，会尝试使用默认前缀的服务器
4. **分组状态查看**：状态接口按前缀分组显示服务器信息
5. **保持原有特性**：仍然支持最少连接数负载均衡、自动心跳检测、过期清理等

## 5. 路由逻辑说明

- 请求 `http://localhost/api/v1/users` → 路由到 `api` 前缀组的服务器
- 请求 `http://localhost/web/dashboard` → 路由到 `web` 前缀组的服务器  
- 请求 `http://localhost/admin/users` → 路由到 `admin` 前缀组的服务器
- 请求 `http://localhost/other/path` → 路由到 `default` 前缀组的服务器

-------------------------方式2-------------------------------------------

## 修改后的 upstream.lua

```lua
-- upstream.lua
local cjson = require "cjson"
local balancer = require "ngx.balancer"
local ngx_shared = ngx.shared.upstream_servers

local _M = {}

-- 服务器过期时间（秒）
local SERVER_EXPIRE_TIME = 120
-- 清理间隔（秒）
local CLEANUP_INTERVAL = 10

-- 获取客户端IP
local function get_client_ip()
    local headers = ngx.req.get_headers()
    local ip = headers["X-Real-IP"] or headers["X-Forwarded-For"] or ngx.var.remote_addr
    -- 处理X-Forwarded-For可能有多个IP的情况
    if type(ip) == "table" then
        ip = ip[1]
    end
    if ip and string.find(ip, ",") then
        ip = string.match(ip, "([^,]+)")
    end
    return ip
end

-- 序列化服务器键
local function get_server_key(host, port)
    return host .. ":" .. port
end

-- 添加或更新服务器
function _M.add_server()
    local args = ngx.req.get_uri_args()
    local host = args.host
    local port = tonumber(args.port)
    local prefix = args.prefix or ""  -- 新增prefix参数
    
    if not port then
        ngx.status = ngx.HTTP_BAD_REQUEST
        ngx.say('{"error": "port is required"}')
        return
    end
    
    -- 如果host为空，使用客户端IP
    if not host or host == "" then
        host = get_client_ip()
    end
    
    local server_key = get_server_key(host, port)
    
    -- 获取现有服务器信息或创建新的
    local server_info_str = ngx_shared:get(server_key)
    local server_info
    
    if server_info_str then
        server_info = cjson.decode(server_info_str)
        server_info.last_heartbeat = ngx.now()
        -- 更新prefix
        server_info.prefix = prefix
        ngx.log(ngx.INFO, "Updated server heartbeat: ", server_key, " prefix: ", prefix)
    else
        server_info = {
            host = host,
            port = port,
            prefix = prefix,  -- 新增prefix字段
            conn_count = 0,
            last_heartbeat = ngx.now(),
            created_time = ngx.now()
        }
        ngx.log(ngx.INFO, "Added new server: ", server_key, " prefix: ", prefix)
    end
    
    -- 保存到共享内存
    local success, err = ngx_shared:set(server_key, cjson.encode(server_info), SERVER_EXPIRE_TIME)
    
    if not success then
        ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
        ngx.say('{"error": "failed to add server: ' .. err .. '"}')
        return
    end
    
    ngx.say('{"success": true, "server": "' .. server_key .. '", "prefix": "' .. prefix .. '"}')
end

-- 移除服务器
function _M.remove_server()
    local args = ngx.req.get_uri_args()
    local host = args.host
    local port = tonumber(args.port)
    
    if not port then
        ngx.status = ngx.HTTP_BAD_REQUEST
        ngx.say('{"error": "port is required"}')
        return
    end
    
    if not host or host == "" then
        host = get_client_ip()
    end
    
    local server_key = get_server_key(host, port)
    local success, err = ngx_shared:delete(server_key)
    
    if not success then
        ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
        ngx.say('{"error": "failed to remove server: ' .. err .. '"}')
        return
    end
    
    ngx.say('{"success": true, "removed": "' .. server_key .. '"}')
end

-- 获取服务器状态
function _M.get_status()
    local servers = {}
    local keys = ngx_shared:get_keys(0)  -- 获取所有键
    
    for _, key in ipairs(keys) do
        local server_info_str = ngx_shared:get(key)
        if server_info_str then
            local server_info = cjson.decode(server_info_str)
            table.insert(servers, server_info)
        end
    end
    
    ngx.header["Content-Type"] = "application/json; charset=utf-8"
    ngx.say(cjson.encode({
        servers = servers,
        total = #servers,
        timestamp = ngx.now()
    }))
end

-- 路径前缀匹配函数
local function match_prefix(request_path, server_prefix)
    if not server_prefix or server_prefix == "" then
        return true  -- 没有设置前缀的服务器匹配所有请求
    end
    
    -- 确保前缀以/开头
    if not server_prefix:startswith("/") then
        server_prefix = "/" .. server_prefix
    end
    
    -- 精确匹配或前缀匹配
    return request_path == server_prefix or request_path:startswith(server_prefix .. "/")
end

-- 为string添加startswith方法（如果不存在）
if not string.startswith then
    function string.startswith(str, start)
        return str:sub(1, #start) == start
    end
end

-- 最少连接数负载均衡（支持前缀过滤）
function _M.least_conn_balancer()
    local request_path = ngx.var.uri  -- 获取请求路径
    
    local least_conn_server = nil
    local least_conn_count = math.huge
    local keys = ngx_shared:get_keys(0)
    
    -- 查找连接数最少的匹配服务器
    for _, key in ipairs(keys) do
        ngx.log(ngx.DEBUG, "Checking server key: ", key)
        local server_info_str = ngx_shared:get(key)
        
        if server_info_str then
            local server_info = cjson.decode(server_info_str)
            
            -- 检查服务器是否过期且前缀匹配
            if ngx.now() - server_info.last_heartbeat <= SERVER_EXPIRE_TIME then
                if match_prefix(request_path, server_info.prefix) then
                    ngx.log(ngx.DEBUG, "Server ", key, " prefix '", server_info.prefix, "' matches request path '", request_path, "'")
                    if server_info.conn_count < least_conn_count then
                        least_conn_count = server_info.conn_count
                        least_conn_server = server_info
                    end
                else
                    ngx.log(ngx.DEBUG, "Server ", key, " prefix '", server_info.prefix, "' does not match request path '", request_path, "'")
                end
            else
                ngx.log(ngx.DEBUG, "Server ", key, " is expired")
            end
        end
    end
    
    if not least_conn_server then
        ngx.log(ngx.ERR, "No available servers found for path: ", request_path)
        return ngx.exit(ngx.HTTP_SERVICE_UNAVAILABLE)
    end
    
    -- 增加连接数
    least_conn_server.conn_count = least_conn_server.conn_count + 1
    local server_key = get_server_key(least_conn_server.host, least_conn_server.port)
    ngx_shared:set(server_key, cjson.encode(least_conn_server), SERVER_EXPIRE_TIME)
    
    -- 记录选择的服务器，用于后续减少连接数
    ngx.ctx.selected_server = server_key
   
    ngx.log(ngx.INFO, "Selected server: ", server_key, " for path: ", request_path, " with prefix: ", least_conn_server.prefix)
    
    -- 设置代理
    local ok, err = balancer.set_current_peer(least_conn_server.host, least_conn_server.port)
    if not ok then
        ngx.log(ngx.ERR, "failed to set current peer: ", err)
        -- 如果设置失败，减少连接数
        _M.decrease_conn_count(server_key)
        return ngx.exit(ngx.HTTP_SERVICE_UNAVAILABLE)
    end
end

-- 减少连接数（在请求完成后调用）
function _M.decrease_conn_count(server_key)
    local server_info_str = ngx_shared:get(server_key)
    if server_info_str then
        local server_info = cjson.decode(server_info_str)
        if server_info.conn_count > 0 then
            server_info.conn_count = server_info.conn_count - 1
            ngx_shared:set(server_key, cjson.encode(server_info), SERVER_EXPIRE_TIME)
        end
    end
end

-- 清理过期服务器
function _M.cleanup_expired_servers()
    local keys = ngx_shared:get_keys(0)
    local removed_count = 0
    
    for _, key in ipairs(keys) do
        local server_info_str = ngx_shared:get(key)
        if server_info_str then
            local server_info = cjson.decode(server_info_str)
            -- 检查服务器是否过期
            if ngx.now() - server_info.last_heartbeat > SERVER_EXPIRE_TIME then
                ngx_shared:delete(key)
                removed_count = removed_count + 1
                ngx.log(ngx.INFO, "Removed expired server: ", key)
            end
        end
    end
    
    if removed_count > 0 then
        ngx.log(ngx.INFO, "Cleanup removed ", removed_count, " expired servers")
    end
end

-- 初始化定时清理任务
function _M.init_cleanup_timer()
    local handler
    handler = function(premature)
        if premature then
            return
        end
        
        _M.cleanup_expired_servers()
        
        -- 再次设置定时器
        ngx.timer.at(CLEANUP_INTERVAL, handler)
    end
    
    -- 启动定时器
    ngx.timer.at(CLEANUP_INTERVAL, handler)
end

return _M
```

## 使用示例

### 1. 注册带有前缀的服务器

```bash
# 注册处理 /api 前缀的服务器
curl "http://nginx-server/upstream/add?host=192.168.1.10&port=8080&prefix=/api"

# 注册处理 /static 前缀的服务器  
curl "http://nginx-server/upstream/add?host=192.168.1.11&port=8080&prefix=/static"

# 注册处理所有请求的服务器（不设置prefix）
curl "http://nginx-server/upstream/add?host=192.168.1.12&port=8080"
```

### 2. 测试请求路由

- 请求 `/api/users` → 路由到 `192.168.1.10:8080`
- 请求 `/static/css/style.css` → 路由到 `192.168.1.11:8080`  
- 请求 `/other/path` → 路由到 `192.168.1.12:8080`（如果没有设置prefix的服务器）

### 3. 查看服务器状态

```bash
curl "http://nginx-server/upstream/status"
```

## 主要改进点

1. **新增 prefix 字段**：在服务器信息中添加了 `prefix` 字段
2. **前缀匹配逻辑**：`match_prefix` 函数根据请求路径和服务器前缀进行匹配
3. **负载均衡过滤**：在最少连接数算法中只考虑前缀匹配的服务器
4. **灵活的匹配规则**：
   - 不设置 `prefix` 的服务器匹配所有请求
   - 设置 `prefix` 的服务器只匹配对应前缀的请求
   - 支持精确匹配和前缀匹配

