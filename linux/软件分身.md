## 1. 使用 unshare 实现基本分身

### 方法1：PID + Mount 命名空间隔离
```bash
#!/bin/bash
# 软件分身脚本: software-clone.sh

APP_PATH="/path/to/your/app"
DATA_DIR="$HOME/.app-clone-$(date +%s)"

# 创建独立数据目录
mkdir -p "$DATA_DIR"/{config,cache,data}

# 运行隔离的程序实例
unshare --pid --fork --mount --mount-proc \
    --uts --hostname "app-clone-$$" \
    --ipc \
    bash -c "
        # 设置独立的环境变量
        export HOME='$DATA_DIR'
        export XDG_CONFIG_HOME='$DATA_DIR/config'
        export XDG_CACHE_HOME='$DATA_DIR/cache'
        
        # 如果需要，挂载独立文件系统
        mount -t tmpfs tmpfs '$DATA_DIR/temp' 2>/dev/null || true
        
        # 运行程序
        exec '$APP_PATH' \"\$@\"
    " -- "$@"
```

### 方法2：网络隔离的分身
```bash
#!/bin/bash
# 网络隔离的分身

unshare --net --uts --hostname "app-net-$$" \
    bash -c "
        # 设置独立的网络配置
        ip link set lo up
        ip addr add 127.0.0.2/8 dev lo
        
        # 运行需要网络隔离的程序
        exec /path/to/app \"\$@\"
    " -- "$@"
```

## 2. 使用 Bubblewrap (bwrap) - 推荐

Bubblewrap 是更安全的分身工具，常用于 Flatpak：

```bash
#!/bin/bash
# 使用 bwrap 创建软件分身

APP_NAME="myapp"
CLONE_ID="clone_$$"
DATA_DIR="$HOME/.${APP_NAME}_${CLONE_ID}"

# 创建独立目录结构
mkdir -p "$DATA_DIR"/{config,cache,data,runtime}

# 使用 bwrap 运行
bwrap \
    --ro-bind / / \
    --bind "$DATA_DIR/config" "$HOME/.config/$APP_NAME" \
    --bind "$DATA_DIR/cache" "$HOME/.cache/$APP_NAME" \
    --bind "$DATA_DIR/data" "$HOME/.local/share/$APP_NAME" \
    --bind "$DATA_DIR/runtime" "/run/user/$(id -u)/$APP_NAME" \
    --dev /dev \
    --dev-bind /dev/dri /dev/dri \
    --proc /proc \
    --tmpfs /tmp \
    --unshare-all \
    --share-net \
    --hostname "${APP_NAME}-clone-$$" \
    --setenv HOME "$HOME" \
    --setenv XDG_CONFIG_HOME "$DATA_DIR/config" \
    --setenv XDG_CACHE_HOME "$DATA_DIR/cache" \
    --setenv XDG_DATA_HOME "$DATA_DIR/data" \
    /path/to/your-app "$@"
```

## 3. 使用 Firejail 沙盒

Firejail 是功能完整的沙盒工具，支持软件分身：

```bash
# 安装
sudo apt install firejail

# 基本使用
firejail --private="/path/to/clone/data" /path/to/app

# 创建专用配置文件
cat > ~/.config/firejail/myapp.profile << EOF
# MyApp 分身配置
private-home .myapp-clone
private-etc hosts,resolv.conf
netfilter
nogroups
no3d
novideo
seccomp
caps.drop all
shell none
EOF

# 使用配置文件运行分身
firejail --profile=myapp.profile /path/to/app
```

## 4. 专用分身脚本示例

### 示例1：浏览器分身
```bash
#!/bin/bash
# browser-clone.sh - 多开浏览器

CLONE_ID="${1:-1}"
PROFILE_DIR="$HOME/.browser-clone-$CLONE_ID"
PORT=$((9222 + CLONE_ID))  # 远程调试端口

# 创建独立配置
mkdir -p "$PROFILE_DIR"

# 运行 Chrome/Chromium 分身
google-chrome \
    --user-data-dir="$PROFILE_DIR" \
    --disk-cache-dir="$PROFILE_DIR/cache" \
    --no-first-run \
    --remote-debugging-port=$PORT \
    "https://www.google.com"

# 或者 Firefox
firefox --profile "$PROFILE_DIR" --no-remote
```

### 示例2：游戏分身（Steam 游戏）
```bash
#!/bin/bash
# steam-game-clone.sh

GAME_ID="730"  # CS:GO 的 AppID
CLONE_ID="clone_$$"
STEAM_DIR="$HOME/.steam-clone-$CLONE_ID"

# 创建独立 Steam 环境
mkdir -p "$STEAM_DIR"/{steam,steamapps,config}

# 设置环境变量
export STEAM_DIR="$STEAM_DIR/steam"
export HOME="$STEAM_DIR"
export LD_LIBRARY_PATH="$STEAM_DIR/steam/ubuntu12_32:$LD_LIBRARY_PATH"

# 运行游戏
unshare --pid --fork --mount --mount-proc \
    --ipc --uts --hostname "steam-game-$CLONE_ID" \
    bash -c "
        # 挂载独立文件系统
        mount -t tmpfs tmpfs '$STEAM_DIR/tmp' 2>/dev/null
        
        # 运行 Steam 游戏
        exec steam -dev -console -noverifyfiles \
            -nobootstrap -no-dwrite -no-browser \
            -applaunch $GAME_ID -novid -windowed
    "
```

### 示例3：Discord/聊天软件分身
```bash
#!/bin/bash
# discord-clone.sh

CLONE_ID="${1:-1}"
DISCORD_DIR="$HOME/.discord-clone-$CLONE_ID"

# 使用 bwrap 运行 Discord 分身
bwrap \
    --ro-bind /usr /usr \
    --ro-bind /lib /lib \
    --ro-bind /lib64 /lib64 \
    --bind "$DISCORD_DIR" "$HOME/.config/discord" \
    --bind "$DISCORD_DIR/cache" "$HOME/.cache/discord" \
    --dev /dev \
    --dev-bind /dev/dri /dev/dri \
    --proc /proc \
    --tmpfs /tmp \
    --unshare-all \
    --share-net \
    --hostname "discord-$CLONE_ID" \
    --setenv HOME "$HOME" \
    --setenv DISPLAY "$DISPLAY" \
    --setenv XAUTHORITY "$XAUTHORITY" \
    /usr/bin/discord
```

## 5. Docker 容器分身方案

```bash
#!/bin/bash
# 使用 Docker 创建软件分身

# 创建 Dockerfile
cat > Dockerfile.app-clone << EOF
FROM alpine:latest
RUN apk add --no-cache xvfb fluxbox x11vnc
COPY app /usr/local/bin/
CMD ["app"]
EOF

# 构建并运行
docker build -t app-clone -f Dockerfile.app-clone .
docker run -d \
    --name "app-clone-$(date +%s)" \
    --hostname "app-clone" \
    --network none \
    --memory="512m" \
    --cpus="1.0" \
    -v "$PWD/data:/data" \
    app-clone
```

## 6. 系统服务化的分身管理器

```bash
#!/bin/bash
# clone-manager.sh - 分身管理器

CLONE_DIR="$HOME/.app-clones"
mkdir -p "$CLONE_DIR"

case "$1" in
    start)
        CLONE_ID="$2"
        APP="$3"
        shift 3
        
        # 创建分身
        nohup unshare --pid --fork --mount --mount-proc \
            --uts --hostname "clone-$CLONE_ID" \
            --ipc --net \
            bash -c "
                echo \$\$ > '$CLONE_DIR/$CLONE_ID.pid'
                exec $APP \"\$@\"
            " -- "$@" > "$CLONE_DIR/$CLONE_ID.log" 2>&1 &
        ;;
    
    stop)
        kill -TERM "$(cat "$CLONE_DIR/$2.pid")" 2>/dev/null
        rm -f "$CLONE_DIR/$2.pid"
        ;;
    
    list)
        ls -la "$CLONE_DIR"/*.pid 2>/dev/null | while read pidfile; do
            pid=$(cat "$pidfile")
            app=$(ps -p "$pid" -o cmd= 2>/dev/null)
            echo "${pidfile##*/}: $app"
        done
        ;;
    
    *)
        echo "Usage: $0 {start|stop|list} [clone-id] [app]"
        ;;
esac
```

## 7. X11 应用的分身注意事项

对于图形程序，需要处理 X11 显示：

```bash
#!/bin/bash
# x11-app-clone.sh

# 创建新的 X server 实例
X_DISPLAY=":$(($(ls /tmp/.X11-unix/ | grep -o '[0-9]\+' | sort -n | tail -1) + 1))"

# 启动新的 X server
Xephyr -screen 1024x768 "$X_DISPLAY" &
XEPHYR_PID=$!

# 在独立命名空间中运行应用
unshare --pid --fork --mount --mount-proc \
    --uts --hostname "xapp-clone-$$" \
    bash -c "
        export DISPLAY='$X_DISPLAY'
        export XAUTHORITY='$HOME/.Xauthority-clone'
        
        # 等待 X server 启动
        sleep 2
        
        # 运行应用
        exec /path/to/x11-app \"\$@\"
    " -- "$@"

kill $XEPHYR_PID
```

## 8. 常见问题解决

### 权限问题：
```bash
# 授予当前用户命名空间权限
sudo sysctl -w kernel.unprivileged_userns_clone=1
```

### DBus 问题：
```bash
# 为分身创建独立 DBus
mkdir -p "$CLONE_DIR/dbus"
dbus-daemon --config-file=/usr/share/dbus-1/session.conf \
    --address="unix:path=$CLONE_DIR/dbus/session" \
    --print-address
```

### PulseAudio 音频：
```bash
# 创建虚拟音频设备
pactl load-module module-null-sink sink_name=clone_sink
export PULSE_SINK=clone_sink
```

## 9. 自动化工具推荐

1. **MultiApp**：专门的多开工具
2. **Sandboxie**：Windows 移植版
3. **Linux Namespace Manager**：管理命名空间的 GUI 工具

这些方法提供了不同程度的隔离，可以根据需要选择。对于生产环境，建议使用 Bubblewrap 或 Firejail，它们更安全且功能完整。
