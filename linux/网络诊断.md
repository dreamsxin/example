```bash
#!/bin/bash

# 连接建立慢问题诊断脚本
# 作者：AI助手
# 版本：1.0

echo "=================================================="
echo "    Linux连接建立慢问题诊断脚本"
echo "=================================================="
echo "检查时间: $(date)"
echo "主机名: $(hostname)"
echo "=================================================="

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 函数：输出带颜色的状态
print_status() {
    local value=$1
    local threshold=$2
    local good_message=$3
    local bad_message=$4
    
    if [ $(echo "$value <= $threshold" | bc 2>/dev/null) = "1" ] || [ "$value" = "正常" ]; then
        echo -e "${GREEN}✓ $good_message${NC}"
    else
        echo -e "${RED}✗ $bad_message${NC}"
    fi
}

# 检查必要的工具
check_tools() {
    echo -e "\n${BLUE}[1/7] 检查必要工具...${NC}"
    local tools="sysctl netstat ss awk grep bc"
    local missing_tools=""
    
    for tool in $tools; do
        if ! command -v $tool &> /dev/null; then
            missing_tools="$missing_tools $tool"
        fi
    done
    
    if [ -n "$missing_tools" ]; then
        echo -e "${RED}缺少必要工具: $missing_tools${NC}"
        echo "请安装这些工具后重新运行脚本"
        exit 1
    else
        echo -e "${GREEN}所有必要工具已安装${NC}"
    fi
}

# 检查系统基本信息
check_system_info() {
    echo -e "\n${BLUE}[2/7] 系统基本信息...${NC}"
    echo "内核版本: $(uname -r)"
    echo "系统架构: $(uname -m)"
    echo "CPU核心数: $(nproc)"
    echo "总内存: $(free -h | awk '/Mem:/ {print $2}')"
    echo "当前负载: $(uptime | awk -F'load average:' '{print $2}')"
}

# 检查当前连接状态
check_connection_status() {
    echo -e "\n${BLUE}[3/7] 当前连接状态统计...${NC}"
    
    # 使用 ss 统计
    echo "--- 连接统计 (ss -s) ---"
    ss -s 2>/dev/null | head -n 10
    
    # 连接状态分布
    echo -e "\n--- TCP连接状态分布 ---"
    ss -ant | awk 'NR>1 {++S[$1]} END {for(a in S) print a, S[a]}' | sort -k2 -nr
    
    # 查看ESTABLISHED连接数
    local established_count=$(ss -ant state established | wc -l)
    echo -e "\n当前ESTABLISHED连接数: $((established_count - 1))"
    
    # 检查端口使用情况
    echo -e "\n--- 常用服务端口监听状态 ---"
    ss -lnt | grep -E ":($(echo "80|443|22|3306|5432|6379|8080" | tr '|' '\\|'))" | sort -k4
}

# 检查内核参数
check_kernel_params() {
    echo -e "\n${BLUE}[4/7] 内核参数检查...${NC}"
    
    # 本地端口范围
    local port_range=$(sysctl net.ipv4.ip_local_port_range 2>/dev/null | awk '{print $3, $4}')
    local port_min=$(echo $port_range | awk '{print $1}')
    local port_max=$(echo $port_range | awk '{print $2}')
    local port_total=$((port_max - port_min + 1))
    
    echo "本地端口范围: $port_range (可用端口数: $port_total)"
    print_status $port_total 20000 "端口数量充足" "可用端口数较少，建议扩大范围"
    
    # 连接跟踪表
    local conntrack_max=$(sysctl net.netfilter.nf_conntrack_max 2>/dev/null | awk '{print $3}')
    local conntrack_count=$(cat /proc/sys/net/netfilter/nf_conntrack_count 2>/dev/null 2>/dev/null || echo "N/A")
    
    if [ "$conntrack_count" != "N/A" ] && [ -n "$conntrack_max" ]; then
        echo "连接跟踪表: $conntrack_count/$conntrack_max"
        local usage_percent=$((conntrack_count * 100 / conntrack_max))
        print_status $usage_percent 80 "连接跟踪表使用率正常" "连接跟踪表接近满载"
    else
        echo "连接跟踪表: 未启用或不可用"
    fi
    
    # 全连接队列大小
    local somaxconn=$(sysctl net.core.somaxconn 2>/dev/null | awk '{print $3}')
    echo "全连接队列最大长度(somaxconn): $somaxconn"
    print_status $somaxconn 1024 "somaxconn设置合理" "somaxconn设置较小，建议增大"
    
    # 半连接队列相关参数
    local tcp_max_syn_backlog=$(sysctl net.ipv4.tcp_max_syn_backlog 2>/dev/null | awk '{print $3}')
    echo "半连接队列最大长度: $tcp_max_syn_backlog"
    
    # TCP Tw参数
    local tcp_tw_reuse=$(sysctl net.ipv4.tcp_tw_reuse 2>/dev/null | awk '{print $3}')
    local tcp_tw_recycle=$(sysctl net.ipv4.tcp_tw_recycle 2>/dev/null | awk '{print $3}' 2>/dev/null || echo "N/A")
    echo "TCP TW重用: tcp_tw_reuse=$tcp_tw_reuse, tcp_tw_recycle=$tcp_tw_recycle"
    
    # 文件描述符限制
    local file_max=$(sysctl fs.file-max 2>/dev/null | awk '{print $3}')
    echo "系统最大文件描述符: $file_max"
}

# 检查系统资源限制
check_resource_limits() {
    echo -e "\n${BLUE}[5/7] 系统资源限制检查...${NC}"
    
    # 系统级文件描述符
    local file_nr=$(cat /proc/sys/fs/file-nr 2>/dev/null)
    local allocated=$(echo $file_nr | awk '{print $1}')
    local free_fd=$(echo $file_nr | awk '{print $2}')  
    local file_max=$(echo $file_nr | awk '{print $3}')
    
    if [ -n "$file_max" ] && [ "$file_max" -gt 0 ]; then
        local fd_usage_percent=$((allocated * 100 / file_max))
        echo "文件描述符使用: $allocated/$file_max (使用率: ${fd_usage_percent}%)"
        print_status $fd_usage_percent 80 "文件描述符充足" "文件描述符使用率较高"
    fi
    
    # 当前用户限制
    echo -e "\n--- 当前用户限制 ---"
    ulimit -a | grep -E "(open files|max user processes)"
    
    # 检查系统内存和Swap
    echo -e "\n--- 内存使用情况 ---"
    free -h
    
    local mem_info=$(free | awk '/Mem:/ {print $3/$2 * 100.0}')
    local swap_info=$(free | awk '/Swap:/ {print $3/$2 * 100.0}' | grep -v "nan")
    
    echo -e "\n内存使用率: $(printf "%.1f" $mem_info)%"
    print_status $(printf "%.0f" $mem_info) 90 "内存使用正常" "内存使用率较高"
    
    if [ -n "$swap_info" ]; then
        echo "Swap使用率: $(printf "%.1f" $swap_info)%"
        print_status $(printf "%.0f" $swap_info) 10 "Swap使用正常" "Swap使用较多，可能影响性能"
    fi
}

# 检查网络队列溢出
check_queue_overflow() {
    echo -e "\n${BLUE}[6/7] 网络队列溢出检查...${NC}"
    
    echo "--- 网络统计信息 ---"
    local stats=$(netstat -s 2>/dev/null)
    
    # 检查监听队列溢出
    local listen_overflows=$(echo "$stats" | grep "listen queue of a socket overflowed" | awk '{print $1}' || echo "0")
    if [ -n "$listen_overflows" ]; then
        echo "全连接队列溢出次数: $listen_overflows"
        print_status $listen_overflows 0 "全连接队列正常" "全连接队列有溢出"
    fi
    
    # 检查SYN被丢弃
    local syn_dropped=$(echo "$stats" | grep -E "SYNs to LISTEN sockets dropped|requests sent out" | awk '{print $1}' | head -1 || echo "0")
    if [ -n "$syn_dropped" ]; then
        echo "SYN包丢弃次数: $syn_dropped"
        print_status $syn_dropped 0 "SYN处理正常" "有SYN包被丢弃"
    fi
    
    # 检查重传
    local retransmits=$(echo "$stats" | grep "segments retransmitted" | awk '{print $1}' || echo "0")
    if [ -n "$retransmits" ]; then
        echo "TCP段重传次数: $retransmits"
        print_status $retransmits 100 "重传率正常" "重传次数较多"
    fi
}

# 生成建议
generate_recommendations() {
    echo -e "\n${BLUE}[7/7] 诊断建议...${NC}"
    
    echo -e "${YELLOW}基于以上检查，建议如下：${NC}"
    
    # 端口范围建议
    local port_range=$(sysctl net.ipv4.ip_local_port_range 2>/dev/null | awk '{print $3, $4}')
    local port_min=$(echo $port_range | awk '{print $1}')
    local port_max=$(echo $port_range | awk '{print $2}')
    local port_total=$((port_max - port_min + 1))
    
    if [ $port_total -lt 20000 ]; then
        echo -e "1. ${YELLOW}建议扩大本地端口范围：${NC}"
        echo "   echo 'net.ipv4.ip_local_port_range = 10000 65000' >> /etc/sysctl.conf"
    fi
    
    # somaxconn建议
    local somaxconn=$(sysctl net.core.somaxconn 2>/dev/null | awk '{print $3}')
    if [ $somaxconn -lt 1024 ]; then
        echo -e "2. ${YELLOW}建议增大全连接队列大小：${NC}"
        echo "   echo 'net.core.somaxconn = 65535' >> /etc/sysctl.conf"
    fi
    
    # 文件描述符建议
    local file_max=$(sysctl fs.file-max 2>/dev/null | awk '{print $3}')
    if [ $file_max -lt 65535 ]; then
        echo -e "3. ${YELLOW}建议增大系统文件描述符限制：${NC}"
        echo "   echo 'fs.file-max = 1000000' >> /etc/sysctl.conf"
        echo "   并在 /etc/security/limits.conf 中添加："
        echo "   * soft nofile 65535"
        echo "   * hard nofile 65535"
    fi
    
    # 连接跟踪建议
    local conntrack_count=$(cat /proc/sys/net/netfilter/nf_conntrack_count 2>/dev/null 2>/dev/null || echo "0")
    local conntrack_max=$(sysctl net.netfilter.nf_conntrack_max 2>/dev/null | awk '{print $3}')
    if [ "$conntrack_count" != "N/A" ] && [ -n "$conntrack_max" ]; then
        local usage_percent=$((conntrack_count * 100 / conntrack_max))
        if [ $usage_percent -gt 80 ]; then
            echo -e "4. ${YELLOW}建议增大连接跟踪表大小：${NC}"
            echo "   echo 'net.netfilter.nf_conntrack_max = 655360' >> /etc/sysctl.conf"
        fi
    fi
    
    # 队列溢出建议
    local listen_overflows=$(netstat -s 2>/dev/null | grep "listen queue of a socket overflowed" | awk '{print $1}' || echo "0")
    if [ $listen_overflows -gt 0 ]; then
        echo -e "5. ${YELLOW}检测到连接队列溢出，需要：${NC}"
        echo "   - 增大 net.core.somaxconn"
        echo "   - 检查应用程序的backlog配置"
        echo "   - 考虑增加应用服务器的工作进程/线程数"
    fi
    
    echo -e "\n${GREEN}应用修改后执行: sysctl -p 使配置生效${NC}"
    echo -e "${YELLOW}注意：修改limits.conf需要重新登录或重启受影响的服务${NC}"
}

# 主执行流程
main() {
    check_tools
    check_system_info
    check_connection_status
    check_kernel_params
    check_resource_limits
    check_queue_overflow
    generate_recommendations
    
    echo -e "\n${GREEN}==================================================${NC}"
    echo -e "${GREEN}                  检查完成${NC}"
    echo -e "${GREEN}==================================================${NC}"
    echo -e "\n${YELLOW}提示：如果问题依然存在，建议使用 tcpdump 进行网络包分析${NC}"
    echo -e "${YELLOW}命令示例: tcpdump -i any -w debug.pcap host <目标IP>${NC}"
}

# 检查是否为root用户
if [ "$EUID" -ne 0 ]; then
    echo -e "${YELLOW}警告：部分检查可能需要root权限才能获取完整信息${NC}"
    echo -e "${YELLOW}建议使用sudo运行此脚本：sudo $0${NC}"
    echo -e "${YELLOW}继续执行非root检查...(按Enter继续，Ctrl+C退出)${NC}"
    read
fi

# 执行主函数
main
```
