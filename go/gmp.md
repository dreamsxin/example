# 协程

协程，又称为用户级线程，核心点如下：

1. 与线程存在映射关系，为 M：1；
2. 创建、销毁、调度在用户态完成，对内核透明，所以更轻；
3. 从属同一个内核级线程，无法并行；一个协程阻塞会导致从属同一线程的所有协程无法执行。

# goroutine

本质是把大量的 `goroutine` 分配到少量线程上去执行, 并利用多核并行, 实现更强大的并发。

Goroutine，经 Golang 优化后的特殊“协程”，核心点如下：

1. 与线程存在映射关系，为 M：N；
2. 创建、销毁、调度在用户态完成，对内核透明，足够轻便；
3. 可利用多个线程，实现并行；
4. 通过调度器的斡旋，实现和线程间的动态绑定和灵活调度；
5. 栈空间大小可动态扩缩，因地制宜.

## gmp 模型
gmp = goroutine + machine + processor （+ 一套有机组合的机制），下面先单独拆出每个组件进行介绍，最后再总览全局，对 gmp 进行总述。

### g
1. g 即goroutine，是 golang 中对协程的抽象；
2. g 有自己的运行栈、状态、以及执行的任务函数（用户通过 go func 指定）；
3. g 需要绑定到 p 才能执行，在 g 的视角中，p 就是它的 cpu.

### p
1. p 即 processor，是 golang 中的调度器；
2. p 是 gmp 的中枢，借由 p 承上启下，实现 g 和 m 之间的动态有机结合；
3. 对 g 而言，p 是其 cpu，g 只有被 p 调度，才得以执行；
4. 对 m 而言，p 是其执行代理，为其提供必要信息的同时（可执行的 g、内存分配情况等），并隐藏了繁杂的调度细节；
5. p 的数量决定了 g 最大并行数量，可由用户通过 GOMAXPROCS 进行设定（超过 CPU 核数时无意义）.

### m
1. m 即 machine，是 golang 中对线程的抽象；
2. m 不直接执行 g，而是先和 p 绑定，由其实现代理；
3. 借由 p 的存在，m 无需和 g 绑死，也无需记录 g 的状态信息，因此 g 在全生命周期中可以实现跨 m 执行.
