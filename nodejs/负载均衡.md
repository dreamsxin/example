# 使用 Node.js 编写 HTTP 服务负载均衡器

## 1. 基础轮询负载均衡器

```javascript
const http = require('http');
const httpProxy = require('http-proxy');

class RoundRobinBalancer {
  constructor(servers) {
    this.servers = servers;
    this.currentIndex = 0;
    this.proxy = httpProxy.createProxyServer();
  }

  getNextServer() {
    const server = this.servers[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.servers.length;
    return server;
  }

  handleRequest(req, res) {
    const target = this.getNextServer();
    console.log(`Routing request to: ${target}`);
    
    this.proxy.web(req, res, {
      target: target,
      timeout: 5000
    });
  }

  start(port) {
    const server = http.createServer((req, res) => {
      this.handleRequest(req, res);
    });

    // 错误处理
    this.proxy.on('error', (err, req, res) => {
      console.error('Proxy error:', err);
      res.writeHead(500, { 'Content-Type': 'text/plain' });
      res.end('Load balancer error');
    });

    server.listen(port, () => {
      console.log(`Load balancer running on port ${port}`);
    });
  }
}

// 使用示例
const servers = [
  'http://localhost:3001',
  'http://localhost:3002',
  'http://localhost:3003'
];

const balancer = new RoundRobinBalancer(servers);
balancer.start(8080);
```

## 2. 带健康检查的负载均衡器

```javascript
const http = require('http');
const httpProxy = require('http-proxy');

class HealthCheckBalancer {
  constructor(servers) {
    this.servers = servers.map(server => ({
      url: server,
      healthy: true,
      failures: 0
    }));
    this.proxy = httpProxy.createProxyServer();
    this.startHealthChecks();
  }

  async checkServerHealth(server) {
    return new Promise((resolve) => {
      const req = http.get(server.url, (res) => {
        server.healthy = res.statusCode === 200;
        if (server.healthy) server.failures = 0;
      });

      req.on('error', () => {
        server.failures++;
        if (server.failures >= 3) {
          server.healthy = false;
        }
      });

      req.setTimeout(3000, () => {
        req.destroy();
        server.failures++;
        if (server.failures >= 3) {
          server.healthy = false;
        }
      });

      req.end();
    });
  }

  startHealthChecks() {
    setInterval(() => {
      this.servers.forEach(server => {
        this.checkServerHealth(server);
      });
    }, 10000); // 每10秒检查一次
  }

  getHealthyServers() {
    return this.servers.filter(server => server.healthy);
  }

  getNextServer() {
    const healthyServers = this.getHealthyServers();
    if (healthyServers.length === 0) {
      throw new Error('No healthy servers available');
    }
    
    // 简单的轮询算法
    const randomIndex = Math.floor(Math.random() * healthyServers.length);
    return healthyServers[randomIndex].url;
  }

  handleRequest(req, res) {
    try {
      const target = this.getNextServer();
      console.log(`Routing to: ${target}`);
      
      this.proxy.web(req, res, {
        target: target,
        timeout: 5000
      });
    } catch (error) {
      res.writeHead(503, { 'Content-Type': 'text/plain' });
      res.end('Service unavailable');
    }
  }

  start(port) {
    const server = http.createServer((req, res) => {
      this.handleRequest(req, res);
    });

    this.proxy.on('error', (err, req, res) => {
      console.error('Proxy error:', err);
      res.writeHead(502, { 'Content-Type': 'text/plain' });
      res.end('Bad gateway');
    });

    server.listen(port, () => {
      console.log(`Health-check load balancer running on port ${port}`);
    });
  }
}

// 使用示例
const servers = [
  'http://localhost:3001',
  'http://localhost:3002',
  'http://localhost:3003'
];

const balancer = new HealthCheckBalancer(servers);
balancer.start(8080);
```

## 3. 基于权重的负载均衡器

```javascript
class WeightedRoundRobinBalancer {
  constructor(servers) {
    this.servers = servers; // [{url: 'http://...', weight: 3}, ...]
    this.currentWeight = 0;
    this.gcd = this.calculateGCD();
    this.maxWeight = this.getMaxWeight();
    this.proxy = httpProxy.createProxyServer();
  }

  calculateGCD() {
    const weights = this.servers.map(s => s.weight);
    let gcd = weights[0];
    
    for (let i = 1; i < weights.length; i++) {
      gcd = this.getTwoNumbersGCD(gcd, weights[i]);
    }
    
    return gcd;
  }

  getTwoNumbersGCD(a, b) {
    while (b !== 0) {
      const temp = b;
      b = a % b;
      a = temp;
    }
    return a;
  }

  getMaxWeight() {
    return Math.max(...this.servers.map(s => s.weight));
  }

  getNextServer() {
    while (true) {
      this.currentWeight = (this.currentWeight + this.gcd) % this.maxWeight;
      
      for (const server of this.servers) {
        if (server.weight >= this.currentWeight) {
          return server.url;
        }
      }
    }
  }

  handleRequest(req, res) {
    const target = this.getNextServer();
    console.log(`Routing to: ${target} (Weighted)`);
    
    this.proxy.web(req, res, {
      target: target,
      timeout: 5000
    });
  }

  start(port) {
    const server = http.createServer((req, res) => {
      this.handleRequest(req, res);
    });

    server.listen(port, () => {
      console.log(`Weighted load balancer running on port ${port}`);
    });
  }
}

// 使用示例
const weightedServers = [
  { url: 'http://localhost:3001', weight: 3 },
  { url: 'http://localhost:3002', weight: 2 },
  { url: 'http://localhost:3003', weight: 1 }
];

const weightedBalancer = new WeightedRoundRobinBalancer(weightedServers);
weightedBalancer.start(8081);
```

## 4. 完整的负载均衡器实现

```javascript
const http = require('http');
const httpProxy = require('http-proxy');
const URL = require('url');

class AdvancedLoadBalancer {
  constructor(options = {}) {
    this.servers = options.servers || [];
    this.algorithm = options.algorithm || 'round-robin';
    this.healthCheckInterval = options.healthCheckInterval || 10000;
    this.failureThreshold = options.failureThreshold || 3;
    
    this.currentIndex = 0;
    this.proxy = httpProxy.createProxyServer();
    
    // 初始化服务器状态
    this.serverStates = this.servers.map(server => ({
      url: server.url || server,
      weight: server.weight || 1,
      healthy: true,
      failures: 0,
      responseTime: 0,
      requests: 0
    }));

    this.startHealthChecks();
  }

  // 健康检查
  async performHealthCheck(serverState) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      
      const req = http.request(serverState.url + '/health', {
        timeout: 3000
      }, (res) => {
        serverState.responseTime = Date.now() - startTime;
        
        if (res.statusCode === 200) {
          serverState.healthy = true;
          serverState.failures = 0;
        } else {
          serverState.failures++;
          if (serverState.failures >= this.failureThreshold) {
            serverState.healthy = false;
          }
        }
        resolve();
      });

      req.on('error', () => {
        serverState.failures++;
        if (serverState.failures >= this.failureThreshold) {
          serverState.healthy = false;
        }
        resolve();
      });

      req.setTimeout(3000, () => {
        req.destroy();
        serverState.failures++;
        if (serverState.failures >= this.failureThreshold) {
          serverState.healthy = false;
        }
        resolve();
      });

      req.end();
    });
  }

  startHealthChecks() {
    setInterval(async () => {
      for (const serverState of this.serverStates) {
        await this.performHealthCheck(serverState);
      }
    }, this.healthCheckInterval);
  }

  // 选择服务器算法
  selectServer() {
    const healthyServers = this.serverStates.filter(s => s.healthy);
    
    if (healthyServers.length === 0) {
      throw new Error('No healthy servers available');
    }

    switch (this.algorithm) {
      case 'round-robin':
        return this.roundRobin(healthyServers);
      
      case 'weighted-round-robin':
        return this.weightedRoundRobin(healthyServers);
      
      case 'least-connections':
        return this.leastConnections(healthyServers);
      
      case 'random':
        return this.randomSelection(healthyServers);
      
      default:
        return this.roundRobin(healthyServers);
    }
  }

  roundRobin(servers) {
    const server = servers[this.currentIndex % servers.length];
    this.currentIndex++;
    return server;
  }

  weightedRoundRobin(servers) {
    const totalWeight = servers.reduce((sum, server) => sum + server.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const server of servers) {
      random -= server.weight;
      if (random <= 0) {
        return server;
      }
    }
    
    return servers[0];
  }

  leastConnections(servers) {
    return servers.reduce((min, server) => 
      server.requests < min.requests ? server : min
    );
  }

  randomSelection(servers) {
    return servers[Math.floor(Math.random() * servers.length)];
  }

  // 处理请求
  async handleRequest(req, res) {
    try {
      const selectedServer = this.selectServer();
      selectedServer.requests++;
      
      console.log(`Routing to: ${selectedServer.url} [${this.algorithm}]`);
      
      this.proxy.web(req, res, {
        target: selectedServer.url,
        timeout: 10000
      });

      // 请求完成时减少计数
      res.on('finish', () => {
        selectedServer.requests--;
      });

    } catch (error) {
      console.error('Load balancing error:', error);
      res.writeHead(503, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        error: 'Service unavailable',
        message: 'All backend servers are down'
      }));
    }
  }

  // 获取状态信息
  getStatus() {
    return {
      algorithm: this.algorithm,
      servers: this.serverStates.map(server => ({
        url: server.url,
        healthy: server.healthy,
        failures: server.failures,
        responseTime: server.responseTime,
        activeRequests: server.requests,
        weight: server.weight
      }))
    };
  }

  start(port) {
    const server = http.createServer((req, res) => {
      // 状态检查端点
      if (req.url === '/balancer-status' && req.method === 'GET') {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(this.getStatus()));
        return;
      }
      
      this.handleRequest(req, res);
    });

    // 代理错误处理
    this.proxy.on('error', (err, req, res) => {
      console.error('Proxy error:', err);
      if (!res.headersSent) {
        res.writeHead(502, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          error: 'Bad gateway',
          message: 'Unable to connect to backend service'
        }));
      }
    });

    server.listen(port, () => {
      console.log(`Advanced load balancer running on port ${port}`);
      console.log(`Using algorithm: ${this.algorithm}`);
      console.log('Status endpoint: http://localhost:' + port + '/balancer-status');
    });

    return server;
  }
}

// 使用示例
const advancedBalancer = new AdvancedLoadBalancer({
  servers: [
    { url: 'http://localhost:3001', weight: 3 },
    { url: 'http://localhost:3002', weight: 2 },
    { url: 'http://localhost:3003', weight: 1 }
  ],
  algorithm: 'weighted-round-robin',
  healthCheckInterval: 15000,
  failureThreshold: 3
});

advancedBalancer.start(8080);
```

## 5. 测试用后端服务器

```javascript
// 简单的测试服务器
function createTestServer(port) {
  const server = http.createServer((req, res) => {
    // 健康检查端点
    if (req.url === '/health') {
      res.writeHead(200);
      res.end('OK');
      return;
    }
    
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      message: `Hello from server ${port}`,
      timestamp: new Date().toISOString(),
      server: `server-${port}`
    }));
  });

  server.listen(port, () => {
    console.log(`Test server running on port ${port}`);
  });

  return server;
}

// 启动多个测试服务器
createTestServer(3001);
createTestServer(3002);
createTestServer(3003);
```

## 安装依赖

```bash
npm init -y
npm install http-proxy
```

## 主要特性

1. **多种负载均衡算法**：轮询、加权轮询、最少连接、随机
2. **健康检查**：定期检查后端服务器状态
3. **故障转移**：自动剔除不健康的服务器
4. **状态监控**：提供负载均衡器状态端点
5. **错误处理**：完善的错误处理和超时控制
6. **可扩展性**：易于添加新的负载均衡算法

# 使用开源库实现 Node.js HTTP 负载均衡器

## 1. 使用 `http-proxy-middleware` + 自定义逻辑

```javascript
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');

class LoadBalancer {
  constructor(servers) {
    this.servers = servers;
    this.currentIndex = 0;
    this.healthyServers = [...servers];
  }

  getNextServer() {
    if (this.healthyServers.length === 0) {
      throw new Error('No healthy servers available');
    }
    
    const server = this.healthyServers[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.healthyServers.length;
    return server;
  }

  createProxy() {
    return (req, res, next) => {
      try {
        const target = this.getNextServer();
        console.log(`Proxying to: ${target}`);
        
        return createProxyMiddleware({
          target: target,
          changeOrigin: true,
          timeout: 5000,
          onError: (err, req, res) => {
            console.error(`Proxy error for ${target}:`, err.message);
            this.markServerUnhealthy(target);
            
            // 重试到下一个服务器
            if (this.healthyServers.length > 0) {
              this.createProxy()(req, res, next);
            } else {
              res.status(503).json({ error: 'Service unavailable' });
            }
          },
          onProxyRes: (proxyRes) => {
            if (proxyRes.statusCode >= 500) {
              this.markServerUnhealthy(target);
            }
          }
        })(req, res, next);
      } catch (error) {
        res.status(503).json({ error: 'Service unavailable' });
      }
    };
  }

  markServerUnhealthy(server) {
    this.healthyServers = this.healthyServers.filter(s => s !== server);
    console.log(`Marked ${server} as unhealthy. Healthy servers: ${this.healthyServers.length}`);
    
    // 定期尝试恢复不健康的服务器
    setTimeout(() => {
      if (!this.healthyServers.includes(server) && this.servers.includes(server)) {
        this.healthyServers.push(server);
        console.log(`Re-added ${server} to healthy servers`);
      }
    }, 30000); // 30秒后重试
  }
}

// 使用示例
const app = express();
const servers = [
  'http://localhost:3001',
  'http://localhost:3002', 
  'http://localhost:3003'
];

const loadBalancer = new LoadBalancer(servers);

// 所有请求都通过负载均衡器
app.use('/', loadBalancer.createProxy());

app.listen(8080, () => {
  console.log('Load balancer running on port 8080');
});
```

## 2. 使用 `loadbalance` 库

```bash
npm install loadbalance
```

```javascript
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const { RoundRobinPool, WeightedRoundRobinPool } = require('loadbalance');

class AdvancedLoadBalancer {
  constructor(servers, options = {}) {
    this.algorithm = options.algorithm || 'round-robin';
    this.pool = this.createPool(servers, options);
    this.healthCheckInterval = options.healthCheckInterval || 10000;
    this.startHealthChecks();
  }

  createPool(servers, options) {
    const serverObjects = servers.map(server => ({
      value: server,
      weight: server.weight || 1
    }));

    switch (this.algorithm) {
      case 'weighted-round-robin':
        return new WeightedRoundRobinPool(serverObjects);
      case 'round-robin':
      default:
        return new RoundRobinPool(serverObjects.map(s => s.value));
    }
  }

  getNextServer() {
    return this.pool.pick();
  }

  createProxy() {
    return createProxyMiddleware({
      router: (req) => this.getNextServer(),
      changeOrigin: true,
      timeout: 5000,
      onError: (err, req, res) => {
        console.error('Proxy error:', err.message);
        res.status(502).json({ error: 'Bad Gateway' });
      },
      onProxyRes: (proxyRes, req, res) => {
        console.log(`[${req.method}] ${req.url} -> ${proxyRes.statusCode}`);
      }
    });
  }

  async checkServerHealth(server) {
    try {
      const response = await fetch(`${server}/health`, { 
        timeout: 3000 
      });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }

  async startHealthChecks() {
    setInterval(async () => {
      console.log('Performing health checks...');
      // 这里可以添加更复杂的健康检查逻辑
    }, this.healthCheckInterval);
  }
}

// 使用示例
const app = express();

const servers = [
  'http://localhost:3001',
  'http://localhost:3002',
  'http://localhost:3003'
];

const loadBalancer = new AdvancedLoadBalancer(servers, {
  algorithm: 'round-robin',
  healthCheckInterval: 15000
});

app.use('/', loadBalancer.createProxy());

// 状态监控端点
app.get('/balancer-status', (req, res) => {
  res.json({
    algorithm: loadBalancer.algorithm,
    status: 'running',
    timestamp: new Date().toISOString()
  });
});

app.listen(8080, () => {
  console.log('Advanced load balancer running on port 8080');
});
```

## 3. 使用 `node-http-proxy` 库

```bash
npm install http-proxy
```

```javascript
const http = require('http');
const httpProxy = require('http-proxy');
const express = require('express');

class NodeHttpProxyBalancer {
  constructor(servers) {
    this.servers = servers;
    this.currentIndex = 0;
    this.proxy = httpProxy.createProxyServer({});
    this.setupProxyEvents();
  }

  setupProxyEvents() {
    this.proxy.on('error', (err, req, res) => {
      console.error('Proxy error:', err);
      if (!res.headersSent) {
        res.writeHead(502, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Bad Gateway' }));
      }
    });

    this.proxy.on('proxyRes', (proxyRes, req, res) => {
      console.log(`[${req.method}] ${req.url} -> ${proxyRes.statusCode}`);
    });
  }

  getNextServer() {
    const server = this.servers[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.servers.length;
    return server;
  }

  handleRequest(req, res) {
    const target = this.getNextServer();
    
    this.proxy.web(req, res, {
      target: target,
      changeOrigin: true,
      timeout: 5000
    });
  }

  start(port) {
    const app = express();

    // 所有请求通过负载均衡器
    app.all('*', (req, res) => {
      this.handleRequest(req, res);
    });

    // 状态端点
    app.get('/balancer/status', (req, res) => {
      res.json({
        servers: this.servers,
        currentIndex: this.currentIndex,
        algorithm: 'round-robin'
      });
    });

    app.listen(port, () => {
      console.log(`Node HTTP Proxy load balancer running on port ${port}`);
    });
  }
}

// 使用示例
const servers = [
  'http://localhost:3001',
  'http://localhost:3002',
  'http://localhost:3003'
];

const balancer = new NodeHttpProxyBalancer(servers);
balancer.start(8080);
```

## 4. 使用 `fast-gateway` 库（API 网关）

```bash
npm install fast-gateway
```

```javascript
const gateway = require('fast-gateway');

const servers = [
  'http://localhost:3001',
  'http://localhost:3002',
  'http://localhost:3003'
];

// 简单的轮询计数器
let currentServer = 0;
function getNextServer() {
  const server = servers[currentServer];
  currentServer = (currentServer + 1) % servers.length;
  return server;
}

const server = gateway({
  routes: [{
    prefix: '/service',
    target: getNextServer(),
    hooks: {
      onRequest: (req, res) => {
        // 动态设置目标服务器
        req.target = getNextServer();
        console.log(`Routing to: ${req.target}`);
      }
    }
  }],
  loadBalancer: {
    strategy: 'round-robin'
  }
});

// 自定义中间件用于负载均衡
server.use('/api', (req, res, next) => {
  req.target = getNextServer();
  next();
});

server.start(8080).then(() => {
  console.log('API Gateway with load balancing running on port 8080');
});
```

## 5. 完整的生产级方案

```javascript
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const morgan = require('morgan');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

class ProductionLoadBalancer {
  constructor(servers, options = {}) {
    this.servers = servers;
    this.algorithm = options.algorithm || 'round-robin';
    this.currentIndex = 0;
    this.serverStats = servers.reduce((acc, server) => {
      acc[server] = { requests: 0, errors: 0, healthy: true };
      return acc;
    }, {});
  }

  getNextServer() {
    switch (this.algorithm) {
      case 'round-robin':
        return this.roundRobin();
      case 'least-connections':
        return this.leastConnections();
      case 'random':
        return this.random();
      default:
        return this.roundRobin();
    }
  }

  roundRobin() {
    let attempts = 0;
    while (attempts < this.servers.length) {
      const server = this.servers[this.currentIndex];
      this.currentIndex = (this.currentIndex + 1) % this.servers.length;
      
      if (this.serverStats[server].healthy) {
        return server;
      }
      attempts++;
    }
    throw new Error('No healthy servers available');
  }

  leastConnections() {
    const healthyServers = this.servers.filter(server => 
      this.serverStats[server].healthy
    );
    
    if (healthyServers.length === 0) {
      throw new Error('No healthy servers available');
    }

    return healthyServers.reduce((minServer, server) => 
      this.serverStats[server].requests < this.serverStats[minServer].requests 
        ? server 
        : minServer
    );
  }

  random() {
    const healthyServers = this.servers.filter(server => 
      this.serverStats[server].healthy
    );
    
    if (healthyServers.length === 0) {
      throw new Error('No healthy servers available');
    }

    return healthyServers[Math.floor(Math.random() * healthyServers.length)];
  }

  createProxyMiddleware() {
    return createProxyMiddleware({
      router: (req) => {
        const target = this.getNextServer();
        this.serverStats[target].requests++;
        console.log(`Routing to: ${target}`);
        return target;
      },
      changeOrigin: true,
      timeout: 10000,
      proxyTimeout: 10000,
      onError: (err, req, res, target) => {
        console.error(`Proxy error for ${target}:`, err.message);
        if (target) {
          this.serverStats[target].errors++;
          // 标记服务器为不健康
          this.serverStats[target].healthy = false;
          setTimeout(() => {
            this.serverStats[target].healthy = true;
            console.log(`Retrying server: ${target}`);
          }, 60000); // 1分钟后重试
        }
        
        if (!res.headersSent) {
          res.status(502).json({ 
            error: 'Service temporarily unavailable',
            message: 'Please try again later'
          });
        }
      },
      onProxyRes: (proxyRes, req, res) => {
        if (proxyRes.statusCode >= 500) {
          // 记录服务器错误
          const target = req.target || 'unknown';
          this.serverStats[target].errors++;
        }
      }
    });
  }

  getStats() {
    return {
      algorithm: this.algorithm,
      servers: this.serverStats,
      timestamp: new Date().toISOString()
    };
  }
}

// 创建 Express 应用
const app = express();

// 安全中间件
app.use(helmet());
app.use(morgan('combined'));

// 速率限制
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 1000 // 限制每个IP 1000次请求每15分钟
});
app.use(limiter);

const servers = [
  'http://localhost:3001',
  'http://localhost:3002',
  'http://localhost:3003'
];

const loadBalancer = new ProductionLoadBalancer(servers, {
  algorithm: 'round-robin'
});

// 负载均衡路由
app.use('/api', loadBalancer.createProxyMiddleware());

// 健康检查端点
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// 统计端点
app.get('/stats', (req, res) => {
  res.json(loadBalancer.getStats());
});

// 错误处理中间件
app.use((err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(500).json({ error: 'Internal server error' });
});

const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
  console.log(`Production load balancer running on port ${PORT}`);
  console.log(`Health check: http://localhost:${PORT}/health`);
  console.log(`Stats: http://localhost:${PORT}/stats`);
});
```

## 6. Package.json 依赖

```json
{
  "name": "node-load-balancer",
  "version": "1.0.0",
  "description": "HTTP Load Balancer using Node.js",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "http-proxy-middleware": "^2.0.6",
    "morgan": "^1.10.0",
    "helmet": "^7.0.0",
    "express-rate-limit": "^6.8.1",
    "loadbalance": "^1.0.0",
    "fast-gateway": "^3.3.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
```

- 简单场景：`http-proxy-middleware`
- API 网关需求：`fast-gateway`
- 生产环境：完整的生产级方案
- 最小依赖：`node-http-proxy`
