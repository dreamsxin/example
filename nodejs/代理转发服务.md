# 增加 SOCKS5 代理支持的完整解决方案

下面将扩展之前的代理转发服务，增加对 SOCKS5 代理的完整支持，包括 SOCKS5 认证和协议处理。

## 1. 安装依赖

首先安装必要的依赖包：

```bash
npm install socks-proxy-agent https-proxy-agent socks
```

## 2. 增强代理转发服务

```javascript
const http = require('http');
const https = require('https');
const net = require('net');
const { URL } = require('url');
const { SocksClient } = require('socks');
const { SocksProxyAgent } = require('socks-proxy-agent');
const { HttpsProxyAgent } = require('https-proxy-agent');

class EnhancedProxyForwardService {
  constructor(options = {}) {
    this.port = options.port || 3128;
    this.upstreamProxy = options.upstreamProxy;
    this.auth = options.auth;
    this.server = null;
    this.isRunning = false;
    this.proxyType = this.detectProxyType(options.upstreamProxy);
  }

  // 检测代理类型
  detectProxyType(proxyUrl) {
    if (!proxyUrl) return 'direct';
    
    const url = new URL(proxyUrl);
    const protocol = url.protocol.toLowerCase();
    
    if (protocol === 'socks:' || protocol === 'socks5:') return 'socks5';
    if (protocol === 'socks4:') return 'socks4';
    if (protocol === 'http:' || protocol === 'https:') return 'http';
    
    return 'http'; // 默认为 HTTP 代理
  }

  // 启动代理转发服务
  start() {
    return new Promise((resolve, reject) => {
      this.server = http.createServer();
      
      this.server.on('request', (clientReq, clientRes) => {
        this.handleHttpRequest(clientReq, clientRes);
      });

      this.server.on('connect', (clientReq, clientSocket, head) => {
        this.handleHttpsRequest(clientReq, clientSocket, head);
      });

      this.server.on('error', (err) => {
        console.error('代理服务器错误:', err);
      });

      this.server.listen(this.port, '127.0.0.1', () => {
        this.isRunning = true;
        console.log(`代理转发服务运行在 127.0.0.1:${this.port}`);
        console.log(`上游代理类型: ${this.proxyType}`);
        resolve();
      });
    });
  }

  // 处理 HTTP 请求
  async handleHttpRequest(clientReq, clientRes) {
    try {
      const targetUrl = new URL(clientReq.url);
      const options = {
        hostname: targetUrl.hostname,
        port: targetUrl.port || (targetUrl.protocol === 'https:' ? 443 : 80),
        path: targetUrl.pathname + targetUrl.search,
        method: clientReq.method,
        headers: { ...clientReq.headers }
      };

      // 移除代理相关的头
      delete options.headers['proxy-connection'];
      delete options.headers['proxy-authorization'];

      // 根据代理类型选择转发方式
      if (this.upstreamProxy) {
        await this.forwardViaUpstreamProxy(clientReq, clientRes, options, false);
      } else {
        // 直接连接目标服务器
        const protocol = targetUrl.protocol === 'https:' ? https : http;
        const proxyReq = protocol.request(options, (proxyRes) => {
          clientRes.writeHead(proxyRes.statusCode, proxyRes.headers);
          proxyRes.pipe(clientRes);
        });

        proxyReq.on('error', (err) => {
          console.error('HTTP代理请求错误:', err);
          clientRes.writeHead(500);
          clientRes.end('Proxy Error');
        });

        clientReq.pipe(proxyReq);
      }
    } catch (error) {
      console.error('HTTP请求处理错误:', error);
      clientRes.writeHead(500);
      clientRes.end('Proxy Error');
    }
  }

  // 处理 HTTPS 请求
  async handleHttpsRequest(clientReq, clientSocket, head) {
    try {
      const [hostname, port] = clientReq.url.split(':');
      const targetPort = port || 443;

      if (this.upstreamProxy) {
        await this.forwardViaUpstreamProxy(clientReq, clientSocket, {
          hostname,
          port: targetPort
        }, true, head);
      } else {
        // 直接连接目标服务器
        const targetSocket = net.connect(targetPort, hostname, () => {
          clientSocket.write('HTTP/1.1 200 Connection Established\r\n\r\n');
          targetSocket.write(head);
          targetSocket.pipe(clientSocket);
          clientSocket.pipe(targetSocket);
        });

        targetSocket.on('error', (err) => {
          console.error('HTTPS代理连接错误:', err);
          clientSocket.end();
        });
      }
    } catch (error) {
      console.error('HTTPS请求处理错误:', error);
      clientSocket.end();
    }
  }

  // 通过上游代理转发（支持 SOCKS5 和 HTTP）
  async forwardViaUpstreamProxy(clientReq, clientResOrSocket, targetOptions, isHttps = false, head = null) {
    if (this.proxyType === 'socks5' || this.proxyType === 'socks4') {
      await this.forwardViaSocksProxy(clientReq, clientResOrSocket, targetOptions, isHttps, head);
    } else {
      await this.forwardViaHttpProxy(clientReq, clientResOrSocket, targetOptions, isHttps, head);
    }
  }

  // 通过 SOCKS 代理转发
  async forwardViaSocksProxy(clientReq, clientResOrSocket, targetOptions, isHttps, head) {
    try {
      const proxyUrl = new URL(this.upstreamProxy);
      const proxyHost = proxyUrl.hostname;
      const proxyPort = parseInt(proxyUrl.port) || 1080;
      
      // 提取认证信息
      let auth = null;
      if (proxyUrl.username || proxyUrl.password) {
        auth = {
          userId: proxyUrl.username,
          password: proxyUrl.password
        };
      } else if (this.auth) {
        const [username, password] = this.auth.split(':');
        auth = {
          userId: username,
          password: password
        };
      }

      const socksOptions = {
        proxy: {
          host: proxyHost,
          port: proxyPort,
          type: this.proxyType === 'socks4' ? 4 : 5,
          ...(auth && { userId: auth.userId, password: auth.password })
        },
        command: 'connect',
        destination: {
          host: targetOptions.hostname,
          port: targetOptions.port || (isHttps ? 443 : 80)
        }
      };

      console.log(`通过 SOCKS${this.proxyType === 'socks4' ? '4' : '5'} 代理连接: ${targetOptions.hostname}:${targetOptions.port}`);

      const { socket } = await SocksClient.createConnection(socksOptions);

      if (isHttps) {
        // HTTPS 连接建立
        clientResOrSocket.write('HTTP/1.1 200 Connection Established\r\n\r\n');
        socket.write(head);
        
        socket.pipe(clientResOrSocket);
        clientResOrSocket.pipe(socket);
      } else {
        // HTTP 请求转发
        const requestData = this.buildHttpRequest(clientReq, targetOptions);
        socket.write(requestData);
        
        socket.on('data', (data) => {
          clientResOrSocket.write(data);
        });
        
        socket.on('end', () => {
          clientResOrSocket.end();
        });
        
        socket.on('error', (err) => {
          console.error('SOCKS代理数据错误:', err);
          clientResOrSocket.end();
        });

        clientReq.on('data', (chunk) => {
          socket.write(chunk);
        });

        clientReq.on('end', () => {
          socket.end();
        });
      }

      socket.on('error', (err) => {
        console.error('SOCKS代理连接错误:', err);
        if (!isHttps) {
          clientResOrSocket.writeHead(500);
          clientResOrSocket.end('SOCKS Proxy Error');
        } else {
          clientResOrSocket.end();
        }
      });

    } catch (error) {
      console.error('SOCKS代理转发错误:', error);
      if (!isHttps) {
        clientResOrSocket.writeHead(500);
        clientResOrSocket.end('SOCKS Proxy Error');
      } else {
        clientResOrSocket.end();
      }
    }
  }

  // 构建 HTTP 请求数据
  buildHttpRequest(clientReq, targetOptions) {
    const path = targetOptions.path || '/';
    let headers = '';
    
    for (const [key, value] of Object.entries(clientReq.headers)) {
      if (key.toLowerCase() !== 'proxy-connection' && key.toLowerCase() !== 'proxy-authorization') {
        headers += `${key}: ${value}\r\n`;
      }
    }
    
    return `${clientReq.method} ${path} HTTP/1.1\r\n` +
           `Host: ${targetOptions.hostname}:${targetOptions.port}\r\n` +
           `${headers}\r\n`;
  }

  // 通过 HTTP 代理转发（原有逻辑）
  async forwardViaHttpProxy(clientReq, clientResOrSocket, targetOptions, isHttps, head) {
    // 原有的 HTTP 代理转发逻辑保持不变
    // 这里省略具体实现，与之前相同
    // ...
  }

  // 停止代理服务
  stop() {
    return new Promise((resolve) => {
      if (this.server) {
        this.server.close(() => {
          this.isRunning = false;
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  // 获取本地代理地址
  getLocalProxyUrl() {
    return `http://127.0.0.1:${this.port}`;
  }

  // 获取代理类型
  getProxyType() {
    return this.proxyType;
  }
}
```

## 3. 增强全局代理管理器

```javascript
const { SocksProxyAgent } = require('socks-proxy-agent');
const { HttpsProxyAgent } = require('https-proxy-agent');

class EnhancedGlobalProxyManager {
  constructor() {
    this.proxyService = null;
    this.originalEnv = { ...process.env };
    this.currentProxy = null;
    this.proxyAgent = null;
  }

  // 设置全局代理环境
  setGlobalProxy(proxyUrl) {
    this.currentProxy = proxyUrl;
    
    // 设置环境变量
    process.env.HTTP_PROXY = proxyUrl;
    process.env.HTTPS_PROXY = proxyUrl;
    process.env.http_proxy = proxyUrl;
    process.env.https_proxy = proxyUrl;

    // 创建对应的代理 Agent
    this.proxyAgent = this.createProxyAgent(proxyUrl);

    console.log(`全局代理已设置为: ${proxyUrl}`);
  }

  // 创建代理 Agent
  createProxyAgent(proxyUrl) {
    if (!proxyUrl) return null;

    try {
      const url = new URL(proxyUrl);
      const protocol = url.protocol.toLowerCase();

      if (protocol === 'socks:' || protocol === 'socks5:' || protocol === 'socks4:') {
        console.log(`创建 SOCKS 代理 Agent: ${proxyUrl}`);
        return new SocksProxyAgent(proxyUrl);
      } else if (protocol === 'http:' || protocol === 'https:') {
        console.log(`创建 HTTP 代理 Agent: ${proxyUrl}`);
        return new HttpsProxyAgent(proxyUrl);
      } else {
        console.warn(`不支持的代理协议: ${protocol}`);
        return null;
      }
    } catch (error) {
      console.error('创建代理 Agent 失败:', error);
      return null;
    }
  }

  // 获取全局 Agent（用于 axios、fetch 等）
  getGlobalAgent() {
    return this.proxyAgent;
  }

  // 创建代理环境下的子进程
  createProxyChildProcess(command, args = [], options = {}) {
    const env = {
      ...process.env,
      ...options.env,
      HTTP_PROXY: this.currentProxy || process.env.HTTP_PROXY,
      HTTPS_PROXY: this.currentProxy || process.env.HTTPS_PROXY,
      http_proxy: this.currentProxy || process.env.http_proxy,
      https_proxy: this.currentProxy || process.env.https_proxy
    };

    // 设置 SOCKS 代理相关环境变量（如果适用）
    if (this.currentProxy && this.currentProxy.includes('socks')) {
      env.ALL_PROXY = this.currentProxy;
      env.all_proxy = this.currentProxy;
    }

    if (process.env.NODE_EXTRA_CA_CERTS) {
      env.NODE_EXTRA_CA_CERTS = process.env.NODE_EXTRA_CA_CERTS;
    }

    const childOptions = {
      ...options,
      env,
      stdio: options.stdio || 'pipe'
    };

    console.log(`创建代理子进程: ${command} ${args.join(' ')}`);
    return spawn(command, args, childOptions);
  }

  // 执行命令并等待完成（带代理环境）
  async execWithProxy(command, options = {}) {
    const env = {
      ...process.env,
      ...options.env,
      HTTP_PROXY: this.currentProxy || process.env.HTTP_PROXY,
      HTTPS_PROXY: this.currentProxy || process.env.HTTPS_PROXY,
      http_proxy: this.currentProxy || process.env.http_proxy,
      https_proxy: this.currentProxy || process.env.https_proxy
    };

    // 设置 SOCKS 代理相关环境变量
    if (this.currentProxy && this.currentProxy.includes('socks')) {
      env.ALL_PROXY = this.currentProxy;
      env.all_proxy = this.currentProxy;
    }

    if (process.env.NODE_EXTRA_CA_CERTS) {
      env.NODE_EXTRA_CA_CERTS = process.env.NODE_EXTRA_CA_CERTS;
    }

    const execOptions = {
      ...options,
      env
    };

    console.log(`执行代理命令: ${command}`);
    return promisify(exec)(command, execOptions);
  }

  // 清除代理设置
  clearGlobalProxy() {
    delete process.env.HTTP_PROXY;
    delete process.env.HTTPS_PROXY;
    delete process.env.http_proxy;
    delete process.env.https_proxy;
    delete process.env.ALL_PROXY;
    delete process.env.all_proxy;
    delete process.env.NODE_EXTRA_CA_CERTS;
    
    this.currentProxy = null;
    this.proxyAgent = null;
    
    console.log('全局代理设置已清除');
  }
}
```

## 4. 增强 Playwright 代理配置

```javascript
const { chromium } = require('playwright');

class EnhancedPlaywrightProxy {
  constructor(proxyManager) {
    this.proxyManager = proxyManager;
  }

  // 启动配置了代理的浏览器
  async launchBrowserWithProxy(options = {}) {
    const browserOptions = {
      headless: options.headless || false,
      args: []
    };

    // 设置代理
    const proxyConfig = this.getProxyConfig();
    if (proxyConfig) {
      browserOptions.proxy = proxyConfig;
    }

    // 时区设置
    if (options.timezone) {
      browserOptions.args.push(`--timezone=${options.timezone}`);
    }

    // 语言设置
    if (options.language) {
      browserOptions.args.push(`--lang=${options.language}`);
    }

    // SOCKS 代理需要额外的参数
    if (proxyConfig && proxyConfig.server.includes('socks')) {
      browserOptions.args.push('--host-resolver-rules="MAP * 0.0.0.0 , EXCLUDE localhost"');
    }

    // 其他配置
    browserOptions.args.push(
      '--no-first-run',
      '--no-default-browser-check',
      '--disable-blink-features=AutomationControlled'
    );

    try {
      const browser = await chromium.launch(browserOptions);
      console.log('浏览器已启动，代理配置:', browserOptions.proxy);
      return browser;
    } catch (error) {
      console.error('启动浏览器失败:', error);
      throw error;
    }
  }

  // 获取代理配置
  getProxyConfig() {
    if (!this.proxyManager.currentProxy) {
      return undefined;
    }

    const proxyUrl = new URL(this.proxyManager.currentProxy);
    const protocol = proxyUrl.protocol.toLowerCase();
    
    const config = {
      server: this.proxyManager.currentProxy
    };

    // 如果代理需要认证
    if (proxyUrl.username && proxyUrl.password) {
      config.username = proxyUrl.username;
      config.password = proxyUrl.password;
    }

    // 对于 SOCKS 代理，Playwright 需要特殊处理
    if (protocol.includes('socks')) {
      console.log('检测到 SOCKS 代理，使用特殊配置');
      // Playwright 会自动识别 SOCKS 代理
    }

    return config;
  }
}
```

## 5. 完整的 SOCKS5 代理服务

```javascript
class Socks5ProxyService {
  constructor() {
    this.proxyService = new EnhancedProxyForwardService();
    this.proxyManager = new EnhancedGlobalProxyManager();
    this.playwrightProxy = new EnhancedPlaywrightProxy(this.proxyManager);
    this.isActive = false;
  }

  // 启动代理服务
  async startProxy(upstreamProxyUrl, options = {}) {
    try {
      console.log('启动代理转发服务...');
      
      // 配置上游代理
      this.proxyService.upstreamProxy = upstreamProxyUrl;
      this.proxyService.auth = options.auth;
      
      // 启动本地代理服务
      await this.proxyService.start();
      
      // 设置全局代理
      const localProxyUrl = this.proxyService.getLocalProxyUrl();
      this.proxyManager.setGlobalProxy(localProxyUrl);
      
      this.isActive = true;
      
      const proxyType = this.proxyService.getProxyType();
      console.log(`代理服务已启动，上游代理: ${upstreamProxyUrl} (${proxyType})`);
      
      return true;
    } catch (error) {
      console.error('启动代理服务失败:', error);
      return false;
    }
  }

  // 停止代理服务
  async stopProxy() {
    try {
      console.log('停止代理服务...');
      
      // 清除全局代理设置
      this.proxyManager.clearGlobalProxy();
      
      // 停止代理服务
      await this.proxyService.stop();
      
      this.isActive = false;
      console.log('代理服务已停止');
      
      return true;
    } catch (error) {
      console.error('停止代理服务失败:', error);
      return false;
    }
  }

  // 启动带代理的浏览器
  async launchBrowser(options = {}) {
    if (!this.isActive) {
      throw new Error('代理服务未启动，请先调用 startProxy()');
    }

    return await this.playwrightProxy.launchBrowserWithProxy(options);
  }

  // 执行命令（继承代理环境）
  async executeCommand(command, args = [], options = {}) {
    return new Promise((resolve, reject) => {
      const child = this.proxyManager.createProxyChildProcess(command, args, options);
      
      let stdout = '';
      let stderr = '';
      
      child.stdout.on('data', (data) => {
        stdout += data.toString();
        if (options.stdout) {
          process.stdout.write(data);
        }
      });
      
      child.stderr.on('data', (data) => {
        stderr += data.toString();
        if (options.stderr) {
          process.stderr.write(data);
        }
      });
      
      child.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout, stderr, code });
        } else {
          reject(new Error(`命令执行失败，退出码: ${code}\n${stderr}`));
        }
      });
      
      child.on('error', reject);
    });
  }

  // 使用代理进行 HTTP 请求
  async makeProxyRequest(url, options = {}) {
    const http = url.startsWith('https') ? require('https') : require('http');
    
    return new Promise((resolve, reject) => {
      const agent = this.proxyManager.getGlobalAgent();
      const requestOptions = {
        ...options,
        agent
      };

      const req = http.request(url, requestOptions, (res) => {
        let data = '';
        res.on('data', (chunk) => {
          data += chunk;
        });
        res.on('end', () => {
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            data: data
          });
        });
      });

      req.on('error', reject);
      req.end();
    });
  }

  // 获取当前代理状态
  getStatus() {
    return {
      isActive: this.isActive,
      localProxy: this.proxyService.getLocalProxyUrl(),
      upstreamProxy: this.proxyService.upstreamProxy,
      proxyType: this.proxyService.getProxyType(),
      globalProxy: this.proxyManager.currentProxy
    };
  }
}
```

## 6. 使用示例和测试

```javascript
// 使用示例
async function testSocks5Proxy() {
  const proxyService = new Socks5ProxyService();

  const testScenarios = [
    {
      name: 'SOCKS5 代理测试',
      proxy: 'socks5://username:password@127.0.0.1:1080',
      type: 'socks5'
    },
    {
      name: 'SOCKS5 无认证测试',
      proxy: 'socks5://127.0.0.1:1080',
      type: 'socks5'
    },
    {
      name: 'HTTP 代理测试',
      proxy: 'http://username:password@proxy.company.com:8080',
      type: 'http'
    },
    {
      name: 'SOCKS4 代理测试',
      proxy: 'socks4://127.0.0.1:1080',
      type: 'socks4'
    }
  ];

  for (const scenario of testScenarios) {
    console.log(`\n=== 测试场景: ${scenario.name} ===`);
    
    try {
      // 启动代理服务
      const started = await proxyService.startProxy(scenario.proxy);
      if (!started) {
        console.log('启动代理服务失败，跳过测试');
        continue;
      }

      console.log('代理状态:', proxyService.getStatus());

      // 测试 HTTP 请求
      console.log('测试 HTTP 请求...');
      try {
        const response = await proxyService.makeProxyRequest('https://httpbin.org/ip');
        console.log('HTTP 请求成功，状态码:', response.statusCode);
        console.log('响应数据:', response.data);
      } catch (error) {
        console.log('HTTP 请求失败:', error.message);
      }

      // 测试子进程
      console.log('测试子进程代理...');
      try {
        await proxyService.executeCommand('curl', [
          '-s', 'https://httpbin.org/ip'
        ], {
          stdout: true,
          timeout: 10000
        });
        console.log('子进程代理测试成功');
      } catch (error) {
        console.log('子进程代理测试失败:', error.message);
      }

      // 测试浏览器
      console.log('测试浏览器代理...');
      try {
        const browser = await proxyService.launchBrowser({
          headless: true,
          timezone: 'Asia/Shanghai'
        });

        const context = await browser.newContext();
        const page = await context.newPage();

        await page.goto('https://httpbin.org/ip', { timeout: 15000 });
        const ipInfo = await page.textContent('body');
        console.log('浏览器代理测试成功:', ipInfo.substring(0, 100));

        await browser.close();
      } catch (error) {
        console.log('浏览器代理测试失败:', error.message);
      }

      // 停止代理服务
      await proxyService.stopProxy();

    } catch (error) {
      console.error(`场景 ${scenario.name} 执行失败:`, error);
    }
  }
}

// 运行测试
if (require.main === module) {
  testSocks5Proxy().catch(console.error);
}

module.exports = {
  Socks5ProxyService,
  EnhancedProxyForwardService,
  EnhancedGlobalProxyManager,
  EnhancedPlaywrightProxy
};
```

## 7. 配置管理和工具函数

```javascript
// proxy-utils.js
const fs = require('fs').promises;
const path = require('path');

class ProxyConfigManager {
  constructor(configPath = './proxy-config.json') {
    this.configPath = configPath;
  }

  // 保存代理配置
  async saveConfig(config) {
    try {
      const dir = path.dirname(this.configPath);
      await fs.mkdir(dir, { recursive: true });
      await fs.writeFile(this.configPath, JSON.stringify(config, null, 2));
      console.log('代理配置已保存到:', this.configPath);
      return true;
    } catch (error) {
      console.error('保存配置失败:', error);
      return false;
    }
  }

  // 加载代理配置
  async loadConfig() {
    try {
      const data = await fs.readFile(this.configPath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      console.error('加载配置失败:', error);
      return null;
    }
  }

  // 验证代理配置
  validateConfig(config) {
    const required = ['proxyUrl'];
    const missing = required.filter(field => !config[field]);
    
    if (missing.length > 0) {
      throw new Error(`缺少必要字段: ${missing.join(', ')}`);
    }

    // 验证代理 URL 格式
    try {
      new URL(config.proxyUrl);
    } catch (error) {
      throw new Error('代理 URL 格式无效');
    }

    return true;
  }
}

// 代理测试工具
class ProxyTester {
  constructor(proxyService) {
    this.proxyService = proxyService;
  }

  // 测试代理连通性
  async testConnectivity(testUrl = 'https://httpbin.org/ip') {
    console.log('测试代理连通性...');
    
    try {
      const response = await this.proxyService.makeProxyRequest(testUrl);
      return {
        success: true,
        statusCode: response.statusCode,
        data: response.data,
        message: '代理连通性测试成功'
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        message: '代理连通性测试失败'
      };
    }
  }

  // 性能测试
  async performanceTest() {
    console.log('开始性能测试...');
    const startTime = Date.now();
    const results = [];
    
    for (let i = 0; i < 5; i++) {
      const testStart = Date.now();
      try {
        await this.proxyService.makeProxyRequest('https://httpbin.org/delay/1');
        const duration = Date.now() - testStart;
        results.push({ success: true, duration });
      } catch (error) {
        results.push({ success: false, duration: Date.now() - testStart, error: error.message });
      }
    }
    
    const totalDuration = Date.now() - startTime;
    const successCount = results.filter(r => r.success).length;
    
    return {
      totalTests: results.length,
      successCount,
      failureCount: results.length - successCount,
      totalDuration,
      averageDuration: totalDuration / results.length,
      details: results
    };
  }
}

module.exports = {
  ProxyConfigManager,
  ProxyTester
};
```

## 8. 使用说明

### 支持的代理格式：

1. **SOCKS5 代理**：
   ```javascript
   socks5://username:password@host:port
   socks5://host:port  // 无认证
   ```

2. **SOCKS4 代理**：
   ```javascript
   socks4://host:port
   ```

3. **HTTP 代理**：
   ```javascript
   http://username:password@host:port
   https://host:port  // HTTPS 代理
   ```

### 基本使用：

```javascript
const { Socks5ProxyService } = require('./socks5-proxy-service');

async function main() {
  const proxyService = new Socks5ProxyService();
  
  // 启动 SOCKS5 代理
  await proxyService.startProxy('socks5://user:pass@proxy.com:1080');
  
  // 使用代理执行命令
  await proxyService.executeCommand('npm', ['install']);
  
  // 使用代理进行 HTTP 请求
  const response = await proxyService.makeProxyRequest('https://api.example.com/data');
  
  // 使用代理启动浏览器
  const browser = await proxyService.launchBrowser();
  
  // 停止代理
  await proxyService.stopProxy();
}

main().catch(console.error);
```

这个完整的解决方案现在支持：

- ✅ SOCKS5 代理（带认证和不带认证）
- ✅ SOCKS4 代理
- ✅ HTTP/HTTPS 代理
- ✅ 全局 Node.js 环境代理设置
- ✅ 子进程代理继承
- ✅ Playwright 浏览器代理配置
- ✅ 代理连通性测试和性能监控
- ✅ 配置持久化

所有通过这个系统创建的进程都会自动继承代理设置，确保整个应用生态都使用相同的代理配置。
