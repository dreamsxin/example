# DuckDB 连接 MySQL 进行跨库查询

DuckDB 提供了强大的跨数据库查询能力，可以直接在 DuckDB 中查询 MySQL 数据库的数据。

## 安装必要扩展

首先需要安装和加载 MySQL 扩展：

```sql
-- 在 DuckDB SQL 中执行
INSTALL mysql;
LOAD mysql;
```

## Golang 中使用 DuckDB 连接 MySQL

### 基本配置和连接

```go
package main

import (
    "database/sql"
    "fmt"
    "log"

    _ "github.com/marcboeker/go-duckdb"
)

func main() {
    // 连接 DuckDB（可以使用内存数据库或文件数据库）
    db, err := sql.Open("duckdb", "")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    // 安装并加载 MySQL 扩展
    _, err = db.Exec("INSTALL mysql;")
    if err != nil {
        log.Fatal("安装mysql扩展失败:", err)
    }
    
    _, err = db.Exec("LOAD mysql;")
    if err != nil {
        log.Fatal("加载mysql扩展失败:", err)
    }

    // 连接到 MySQL 数据库
    err = connectToMySQL(db)
    if err != nil {
        log.Fatal(err)
    }
}

func connectToMySQL(db *sql.DB) error {
    // MySQL 连接配置
    mysqlConfig := map[string]string{
        "host":     "localhost",
        "port":     "3306",
        "user":     "root",
        "password": "your_password",
        "database": "test_db",
    }

    // 创建 MySQL 连接
    attachSQL := fmt.Sprintf(`
        ATTACH 'host=%s user=%s password=%s database=%s port=%s' 
        AS mysql_db (TYPE mysql)
    `, mysqlConfig["host"], mysqlConfig["user"], mysqlConfig["password"], 
       mysqlConfig["database"], mysqlConfig["port"])

    _, err := db.Exec(attachSQL)
    if err != nil {
        return fmt.Errorf("连接MySQL失败: %v", err)
    }

    fmt.Println("成功连接到 MySQL 数据库")
    return nil
}
```

### 跨库查询示例

```go
func crossDatabaseQuery(db *sql.DB) error {
    fmt.Println("\n=== 跨库查询示例 ===")

    // 示例1: 直接查询 MySQL 表
    fmt.Println("1. 查询 MySQL 用户表:")
    rows, err := db.Query(`
        SELECT id, name, email 
        FROM mysql_db.users 
        WHERE created_at > '2023-01-01'
        LIMIT 5
    `)
    if err != nil {
        return err
    }
    defer rows.Close()

    for rows.Next() {
        var id int
        var name, email string
        err = rows.Scan(&id, &name, &email)
        if err != nil {
            return err
        }
        fmt.Printf("ID: %d, Name: %s, Email: %s\n", id, name, email)
    }

    // 示例2: 将 MySQL 数据导入 DuckDB
    fmt.Println("\n2. 导入 MySQL 数据到 DuckDB:")
    _, err = db.Exec(`
        CREATE TABLE local_users AS 
        SELECT * FROM mysql_db.users
    `)
    if err != nil {
        return err
    }
    fmt.Println("数据导入完成")

    // 示例3: 联合查询（DuckDB 本地表和 MySQL 远程表）
    fmt.Println("\n3. 联合查询示例:")
    jointRows, err := db.Query(`
        SELECT 
            m.id as mysql_id,
            m.name as mysql_name,
            l.id as local_id,
            l.data as local_data
        FROM mysql_db.users m
        LEFT JOIN local_products l ON m.id = l.user_id
        WHERE m.status = 'active'
    `)
    if err != nil {
        return err
    }
    defer jointRows.Close()

    // 处理联合查询结果...
    
    return nil
}
```

### 高级跨库操作

```go
func advancedCrossDatabaseOperations(db *sql.DB) error {
    fmt.Println("\n=== 高级跨库操作 ===")

    // 1. 数据同步和ETL
    fmt.Println("1. ETL 操作 - 从 MySQL 同步数据到 DuckDB:")
    _, err := db.Exec(`
        CREATE OR REPLACE TABLE user_summary AS
        SELECT 
            u.id,
            u.name,
            u.email,
            COUNT(o.id) as order_count,
            SUM(o.amount) as total_amount
        FROM mysql_db.users u
        LEFT JOIN mysql_db.orders o ON u.id = o.user_id
        WHERE u.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
        GROUP BY u.id, u.name, u.email
        HAVING total_amount > 1000
    `)
    if err != nil {
        return err
    }

    // 2. 复杂分析查询
    fmt.Println("2. 复杂分析查询:")
    analysisRows, err := db.Query(`
        WITH monthly_stats AS (
            SELECT 
                DATE_TRUNC('month', o.created_at) as month,
                COUNT(DISTINCT o.user_id) as active_users,
                SUM(o.amount) as monthly_revenue,
                AVG(o.amount) as avg_order_value
            FROM mysql_db.orders o
            GROUP BY DATE_TRUNC('month', o.created_at)
        )
        SELECT 
            month,
            active_users,
            monthly_revenue,
            avg_order_value,
            LAG(monthly_revenue) OVER (ORDER BY month) as prev_month_revenue,
            (monthly_revenue - LAG(monthly_revenue) OVER (ORDER BY month)) / 
            LAG(monthly_revenue) OVER (ORDER BY month) * 100 as growth_rate
        FROM monthly_stats
        ORDER BY month DESC
    `)
    if err != nil {
        return err
    }
    defer analysisRows.Close()

    // 处理分析结果...
    
    return nil
}
```

### 完整示例程序

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"

    _ "github.com/marcboeker/go-duckdb"
)

type MySQLConfig struct {
    Host     string
    Port     string
    User     string
    Password string
    Database string
}

func main() {
    // 配置 MySQL 连接
    mysqlConfig := MySQLConfig{
        Host:     "localhost",
        Port:     "3306",
        User:     "root",
        Password: "your_password",
        Database: "business",
    }

    // 初始化 DuckDB
    duckDB, err := initDuckDB()
    if err != nil {
        log.Fatal(err)
    }
    defer duckDB.Close()

    // 连接到 MySQL
    err = attachMySQL(duckDB, mysqlConfig)
    if err != nil {
        log.Fatal(err)
    }

    // 执行跨库查询
    err = executeCrossDatabaseQueries(duckDB)
    if err != nil {
        log.Fatal(err)
    }
}

func initDuckDB() (*sql.DB, error) {
    db, err := sql.Open("duckdb", "cross_db_query.db")
    if err != nil {
        return nil, err
    }

    // 安装和加载必要扩展
    _, err = db.Exec("INSTALL mysql; LOAD mysql;")
    if err != nil {
        return nil, fmt.Errorf("加载MySQL扩展失败: %v", err)
    }

    fmt.Println("DuckDB 初始化完成")
    return db, nil
}

func attachMySQL(db *sql.DB, config MySQLConfig) error {
    attachSQL := fmt.Sprintf(`
        ATTACH 'host=%s user=%s password=%s database=%s port=%s' 
        AS mysql_db (TYPE mysql)
    `, config.Host, config.User, config.Password, config.Database, config.Port)

    _, err := db.Exec(attachSQL)
    if err != nil {
        return fmt.Errorf("连接MySQL失败: %v", err)
    }

    fmt.Printf("成功连接到 MySQL 数据库: %s\n", config.Database)
    return nil
}

func executeCrossDatabaseQueries(db *sql.DB) error {
    startTime := time.Now()

    // 示例1: 简单的数据迁移
    fmt.Println("\n--- 数据迁移示例 ---")
    _, err := db.Exec(`
        CREATE TABLE IF NOT EXISTS local_customers AS
        SELECT 
            id, 
            name, 
            email,
            created_at,
            country
        FROM mysql_db.customers 
        WHERE status = 'active' 
        AND created_at > '2023-01-01'
    `)
    if err != nil {
        return err
    }

    // 示例2: 业务分析报告
    fmt.Println("--- 业务分析报告 ---")
    rows, err := db.Query(`
        SELECT 
            c.country,
            COUNT(DISTINCT c.id) as customer_count,
            COUNT(o.id) as order_count,
            SUM(o.total_amount) as total_revenue,
            AVG(o.total_amount) as avg_order_value
        FROM mysql_db.customers c
        LEFT JOIN mysql_db.orders o ON c.id = o.customer_id
        WHERE o.order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 90 DAY)
        GROUP BY c.country
        ORDER BY total_revenue DESC
    `)
    if err != nil {
        return err
    }
    defer rows.Close()

    fmt.Println("国家\t客户数\t订单数\t总收入\t平均订单值")
    for rows.Next() {
        var country string
        var customerCount, orderCount int
        var totalRevenue, avgOrderValue float64
        
        err = rows.Scan(&country, &customerCount, &orderCount, &totalRevenue, &avgOrderValue)
        if err != nil {
            return err
        }
        fmt.Printf("%s\t%d\t%d\t%.2f\t%.2f\n", 
            country, customerCount, orderCount, totalRevenue, avgOrderValue)
    }

    // 示例3: 性能对比
    fmt.Println("--- 性能对比查询 ---")
    var duckDBTime, mysqlTime time.Duration
    
    // DuckDB 查询时间
    start := time.Now()
    _, err = db.Query("SELECT COUNT(*) FROM local_customers")
    duckDBTime = time.Since(start)
    
    // MySQL 查询时间
    start = time.Now()
    _, err = db.Query("SELECT COUNT(*) FROM mysql_db.customers")
    mysqlTime = time.Since(start)
    
    fmt.Printf("DuckDB 查询时间: %v\n", duckDBTime)
    fmt.Printf("MySQL 查询时间: %v\n", mysqlTime)

    totalTime := time.Since(startTime)
    fmt.Printf("\n总执行时间: %v\n", totalTime)
    
    return nil
}
```

### 连接多个 MySQL 实例

```go
func connectMultipleMySQLInstances(db *sql.DB) error {
    // 连接第一个 MySQL 实例
    _, err := db.Exec(`
        ATTACH 'host=db1.company.com user=readonly password=pass database=sales' 
        AS mysql_sales (TYPE mysql)
    `)
    if err != nil {
        return err
    }

    // 连接第二个 MySQL 实例
    _, err = db.Exec(`
        ATTACH 'host=db2.company.com user=readonly password=pass database=inventory' 
        AS mysql_inventory (TYPE mysql)
    `)
    if err != nil {
        return err
    }

    // 跨多个 MySQL 实例查询
    rows, err := db.Query(`
        SELECT 
            s.salesperson_id,
            s.salesperson_name,
            SUM(s.amount) as total_sales,
            COUNT(i.product_id) as products_managed
        FROM mysql_sales.salespeople s
        LEFT JOIN mysql_inventory.products i ON s.salesperson_id = i.managed_by
        GROUP BY s.salesperson_id, s.salesperson_name
        ORDER BY total_sales DESC
    `)
    if err != nil {
        return err
    }
    defer rows.Close()

    // 处理结果...
    return nil
}
```

## 注意事项

1. **性能考虑**：跨库查询可能比在单一数据库中查询慢，因为涉及网络传输
2. **数据类型映射**：注意 MySQL 和 DuckDB 之间的数据类型差异
3. **连接管理**：及时关闭连接，避免资源泄露
4. **错误处理**：妥善处理连接失败和查询超时情况
5. **安全**：不要在代码中硬编码密码，使用环境变量或配置文件
