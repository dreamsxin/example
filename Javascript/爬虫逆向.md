## 跟踪

### 🕵️‍♂️ 如何调试跟踪滑块行为的 JS

调试滑块的核心在于**通过开发者工具捕捉验证的关键时刻，并定位到核心加密代码**。

1.  **Network 面板抓包，确定入口**：
    *   **操作**：打开浏览器的开发者工具（F12），切换到 `Network` 面板，勾选 `Preserve log`。
    *   **目的**：当你拖动滑块完成验证时，会捕获到包含验证参数（如 `ticket`, `validate`, `bss` 等）的请求包。找到这个包，就找到了逆向分析的目标。

2.  **XHR 断点，定位加密位置**：
    *   **操作**：在 `Sources` 面板右侧的 `XHR/fetch Breakpoints` 中，添加上一步找到的请求 URL 的关键词（如 `validate`）。
    *   **效果**：当 JS 代码准备发送这个验证请求时，执行会暂停。通过调用栈 (`Call Stack`) 回溯，就能找到生成加密参数的核心函数。

3.  **JS 代码断点调试**：
    *   **DOM 事件断点**：在 `Elements` 面板中，找到滑块的 HTML 元素，右键 → `Break on` → `attribute modifications` 或 `subtree modifications`，可以监听拖动时元素属性的变化。
    *   **代码内部分析**：在暂停的地方，多关注 `canvas` 元素的操作，因为滑块和背景图往往绘制在其中。同时，单步执行，观察生成的参数（如加密后的 `vi` 值）是如何被构造出来的。

4.  **分析滑动轨迹**：
    *   高安全等级的网站不仅校验终点，还会分析滑动的**加速度、停顿等轨迹特征**。你可以通过在移动事件中 `console.log` 当前坐标，来研究网站是否对轨迹有特殊要求。
### 💡 补充提示

*   **关于工具**：除了手动调试，你也可以利用 `selenium` 等自动化工具来辅助验证你的分析结果，但在调试阶段，手动打断点观察数据变化是理解原理的最佳途径。
*   **注意更新**：网站的验证逻辑和前端代码会频繁更新，书中案例和网上的教程可能很快过时，**掌握调试方法本身比照搬代码更重要**。

## 变化

### 🔍 针对“文本”变化：寻找内嵌数据源
如果文本变化没有触发网络请求，数据极有可能在初始加载时就埋在了页面里 。

*   **查看页面源代码**：在页面右键 → “查看网页源代码”（不是“检查”）。搜索页面上看到的**关键文本**，如果能搜到，说明数据是静态渲染的；如果搜不到，再按下面两步走。
*   **搜索 `<script>` 标签**：在源码中寻找包含数据的 JSON 对象或数组。这些数据往往赋值给全局变量（如 `window._initData = {...}`），供后续 JS 使用 。
*   **使用全局搜索**：在 `Sources` 面板按 `Ctrl+Shift+F`，全局搜索页面的特征字符串，定位数据所在的文件 。
*   **DOM 断点**：如果数据最终是通过 JS 写入 DOM 的，可以在 `Elements` 面板对应元素上右键 → `Break on` → `subtree modifications`。当文本被更新时，代码会暂停，带你找到修改文本的那一行 JS 。

### 🎨 针对“Canvas”变化：捕获绘制行为
Canvas 一旦绘制完成就是静态的，要更新必须执行**重绘**（通常是 `clearRect` 加新的 `draw` 方法）。

*   **监听重绘函数**：在 `Sources` 面板搜索常见的绘图 API，如 `fillText`、`drawImage`、`clearRect`。找到后打上断点，当 Canvas 内容变化时，执行就会暂停。
*   **使用事件监听器断点**：在 `Sources` → `Event Listener Breakpoints` 中，展开 `Canvas`，勾选相关事件（如 `createImageData`）。或者勾选 `Control` 中的 `requestAnimationFrame`，很多动画循环都在此更新 。
*   **监控数据变化**：如果知道控制绘制的数据在某个对象中，可以在 `Sources` 的 `Watch` 面板添加该对象。或者在操作该对象的代码行（如 `obj.frame = 5`）上设置**条件断点**，观察数据变化如何触发绘图 。

### 💡 核心思路
无论跟踪文本还是 Canvas，逻辑都是一样的：**找到驱动视图变化的核心数据，再反查是谁修改了它**。在无 XHR 的情况下，关键在于从初始 HTML 或内存对象中挖掘这些数据，而不是盯着网络请求 。

面对混淆的数据，调试策略需要从“直接阅读”转向“动态跟踪”和“逻辑还原”。核心思路是：**在代码运行时捕捉其解密后的真实值，或利用工具将混淆代码结构还原为可读形式。**

## 数据混淆

### 🕵️ 动态调试：在运行时抓取“现形”的值
即使变量名变成 `_0x3a2f9b`，数据在内存里也是**真实且未加密的**。我们的目标就是在那“现形”的一刻抓住它。

*   **条件断点与Watch（核心技巧）**：不要试图通读代码，而是推测数据出现的位置。比如怀疑 Canvas 内容由 `_0x3a2f9b` 控制，就在操作它的代码行设断点，右键断点选择 **"Edit breakpoint"** 输入 `_0x3a2f9b !== undefined` 等条件，命中时在 **Scope** 面板查看其真实值 。
*   **覆写与Hook（主动出击）**：如果数据在对象里（如 `app.data`），可在 Console 执行 `app.data = new Proxy(app.data, {set: ...})` 来监听修改。若怀疑是Base64编码 ，找到解码函数后直接在 Console 调用它，把密文传进去看输出。
*   **堆栈回溯（Call Stack）**：命中断点后，通过 **Call Stack** 面板回溯调用链，找到数据被赋值的源头 。

### 🔧 静态还原：借助工具“祛魅”
如果动态调试找不到头绪，可以借助工具将混淆代码“翻译”成人能看懂的样子。

*   **代码美化**：先用 [JSBeautifier](https://jsbeautifier.org/) 之类的工具格式化，至少让代码有缩进和换行 。
*   **自动化反混淆**：更复杂的混淆（如控制流扁平化）可以用 [de4js](https://lelinhtinh.github.io/de4js/)  或 **Webcrack**  这类工具自动处理。
*   **AI 辅助分析**：像 [jsunpack.tech](https://www.jsunpack.tech/) 这类工具能利用 AI 还原语义化变量名，甚至生成控制流图，帮你理解代码逻辑 。

### 💡 实战技巧：从“结果”倒推“过程”
结合你之前的问题，可以利用浏览器的 **Overrides** 功能 ：
1.  在 `Sources` 面板保存混淆的 JS 文件到本地。
2.  用上面提到的工具对本地文件进行反混淆和格式化。
3.  在格式化后的代码中插入大量 `console.log`，打印关键变量的值。
4.  用本地文件**替换**线上文件执行，这样 Console 里输出的就都是可读的日志了。

总的来说，面对混淆数据时，**“动态调试”**是最高效的手段，因为它直接面对内存中的真实值。如果代码逻辑过于复杂，再借助**自动化工具**进行静态还原。

## 覆写和 Hook

### 1利用浏览器开发工具：Local Overrides（最方便）
这是 Chrome 官方提供的**持久化替换资源**功能。它会拦截页面请求，用你修改后的本地文件替代线上文件，非常适合修改特定的 JS 逻辑 。

*   **操作步骤**：
    1.  **设置**：在 `Sources` 面板，点击 `Overrides` 选项卡，选择一个本地空文件夹，并在顶部弹窗中点击 **Allow** 授权 。
    2.  **修改**：在 `Sources` 面板中找到你想要 Hook 的 JS 文件，直接编辑你的覆写代码。
    3.  **保存**：按 `Ctrl+S` (Windows) 或 `Cmd+S` (Mac) 保存。修改后的文件会变紫，并存到本地 。
*   **效果**：之后只要这个开发者工具开着，每次加载该文件都会自动使用你的修改版，**重启浏览器也有效** 。

### 使用油猴脚本 (Tampermonkey)（最强大）
油猴脚本是管理用户脚本的利器，能让你在页面加载的**特定时机**自动执行自定义代码 。

*   **核心思路**：通过 `@match` 或 `@include` 指定目标网站，脚本就会自动运行。
*   **示例代码**：Hook 特定对象的方法 。
    ```javascript
    // ==UserScript==
    // @name         持久化 Hook 示例
    // @namespace    http://tampermonkey.net/
    // @version      1.0
    // @description  页面加载后自动执行 Hook
    // @author       You
    // @match        https://你要hook的网站.com/*
    // @grant        none
    // ==/UserScript==

    (function() {
        'use strict';
        console.log('油猴脚本已启动，开始 Hook...');

        // 在这里粘贴你的 Hook 代码
        // 例如，Hook 一个全局对象的属性
        let originalFunc = window.someObject.someMethod;
        window.someObject.someMethod = function() {
            console.log('方法被调用了，参数是：', arguments);
            // 执行你的逻辑，然后调用原方法
            return originalFunc.apply(this, arguments);
        };
    })();
    ```
*   **效果**：关闭浏览器再打开，只要脚本在，Hook 就一直在。

### 3. 通过控制台初始化：Snippets（最灵活）
适合写一些复杂的调试代码，每次需要时手动运行 。

*   **操作步骤**：
    1.  在 `Sources` 面板找到 `Snippets` 选项卡，新建一个文件。
    2.  把你那套复杂的 Proxy 覆写代码粘贴进去保存。
    3.  每次刷新页面后，在 `Snippets` 里右键你的文件选择 **Run**，所有 Hook 就生效了 。

### 💡 小技巧：快速重载代码
如果你觉得每次手动 Run Snippet 麻烦，可以把代码封装成一个 IIFE，直接在控制台运行，也能快速重载：

```javascript
// 把你的 Hook 代码定义成一个函数，然后立即执行
(function setupHooks() {
    console.log('设置持久化 Hook...');
    // ... 你的 Proxy 和 Hook 逻辑 ...
})();
```

这三种方案里，**Local Overrides** 最适合替换整个文件逻辑，**油猴脚本** 最灵活通用，**Snippets** 则适合临时调试。你可以根据实际场景选择。

如果某个方案在实施过程中遇到问题，比如 Overrides 没生效或者油猴脚本冲突，随时可以再来问我。
