# 函数调用劫持与栈帧操作

## 一、基本原理

### 1. **栈帧结构（x86-64为例）**
```
高地址
+-------------------+
|     调用者栈帧     |
+-------------------+
|   返回地址(RIP)    | ← 修改这里可以劫持返回
+-------------------+
|   保存的RBP        |
+-------------------+
|   局部变量         |
+-------------------+
|   参数区域         | ← 修改这里可以改变参数
+-------------------+
|     当前栈帧       |
+-------------------+
低地址
```

## 二、方法一：通过函数包装器（最简单安全）

```c
#include <stdio.h>

// 原函数
int original_function(int a, int b) {
    printf("Original: %d + %d = ", a, b);
    return a + b;
}

// 前置处理函数
void pre_hook(int *a, int *b) {
    printf("[Pre-hook] Modifying arguments...\n");
    *a *= 2;    // 修改第一个参数
    *b += 10;   // 修改第二个参数
    printf("[Pre-hook] New args: a=%d, b=%d\n", *a, *b);
}

// 后置处理函数
void post_hook(int *result) {
    printf("[Post-hook] Modifying return value...\n");
    *result *= 3;  // 修改返回值
}

// 包装器函数
int wrapped_function(int a, int b) {
    int modified_a = a;
    int modified_b = b;
    
    // 1. 调用前置钩子
    pre_hook(&modified_a, &modified_b);
    
    // 2. 调用原函数
    int result = original_function(modified_a, modified_b);
    
    // 3. 调用后置钩子
    post_hook(&result);
    
    printf("Final result: %d\n", result);
    return result;
}

int main() {
    printf("Calling wrapped function:\n");
    int result = wrapped_function(5, 3);
    printf("Main got: %d\n", result);
    return 0;
}
```

## 三、方法二：使用GCC的函数包装功能

```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>

// 需要链接 -ldl

// 原函数声明
int target_function(int a, int b);

// 实际的函数实现
int real_target_function(int a, int b) {
    printf("Real function called with %d, %d\n", a, b);
    return a - b;  // 注意：这里我们做减法
}

// 使用 __attribute__((weak)) 和包装器
int __real_target_function(int a, int b);

// 包装函数 - 会被链接器优先使用
int __wrap_target_function(int a, int b) {
    printf("[Wrapper] Before call - modifying args\n");
    
    // 修改参数
    a += 100;
    b += 50;
    
    // 调用原函数
    int result = __real_target_function(a, b);
    
    printf("[Wrapper] After call - modifying result\n");
    result *= 2;  // 修改返回值
    
    return result;
}

// 编译时需要：gcc -Wl,--wrap=target_function -o program program.c

int main() {
    int r = target_function(10, 5);
    printf("Result: %d\n", r);
    return 0;
}
```

## 四、方法三：直接栈帧操作（危险！）

```c
#include <stdio.h>
#include <stdint.h>
#include <string.h>

// 危险操作：直接修改栈帧
// 这是平台相关的（x86-64 Linux）

// 目标函数
int target_func(int a, int b) {
    printf("Target: %d + %d = ", a, b);
    int result = a + b;
    printf("%d\n", result);
    return result;
}

// 通过内联汇编获取返回地址
void* get_return_address() {
    void* addr;
    __asm__ volatile (
        "movq 8(%%rbp), %0"  // 从栈帧中获取返回地址
        : "=r"(addr)
    );
    return addr;
}

// 修改栈帧上的参数
void modify_args_on_stack(int *arg1_ptr, int *arg2_ptr) {
    // 假设我们知道参数在栈上的位置
    // 这高度依赖于调用约定和编译器优化
    *arg1_ptr = 999;
    *arg2_ptr = 888;
}

// 劫持返回值的包装器
int __attribute__((noinline)) hijack_wrapper() {
    int a = 10, b = 20;
    printf("Before hijack: a=%d, b=%d\n", a, b);
    
    // 获取参数地址（危险！）
    modify_args_on_stack(&a, &b);
    
    int result = target_func(a, b);
    
    // 修改返回值
    result += 1000;
    
    return result;
}

int main() {
    int r = hijack_wrapper();
    printf("Main got: %d\n", r);
    return 0;
}
```

## 五、方法四：使用信号处理程序修改上下文

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <signal.h>
#include <ucontext.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <sys/mman.h>

// 需要 root 权限或适当的能力
// 编译: gcc -g -o sig_hijack sig_hijack.c

// 目标函数
void target_function(int x) {
    printf("Target function called with: %d\n", x);
}

// 信号处理程序 - 可以修改寄存器上下文
void signal_handler(int sig, siginfo_t *info, void *ucontext) {
    ucontext_t *uc = (ucontext_t *)ucontext;
    
    printf("Signal handler: RIP = %p\n", (void*)uc->uc_mcontext.gregs[REG_RIP]);
    
    // 修改参数（在RDI寄存器中，对于x86-64的第一个参数）
    uc->uc_mcontext.gregs[REG_RDI] = 9999;  // 修改第一个参数
    
    // 注意：不能直接修改返回值，因为函数还没执行
}

int main() {
    struct sigaction sa;
    
    // 设置信号处理
    sa.sa_sigaction = signal_handler;
    sa.sa_flags = SA_SIGINFO | SA_RESTART;
    sigemptyset(&sa.sa_mask);
    
    // 使用SIGTRAP或自定义信号
    if (sigaction(SIGTRAP, &sa, NULL) == -1) {
        perror("sigaction");
        return 1;
    }
    
    printf("Calling target function...\n");
    
    // 这里无法直接触发信号，实际应用中需要：
    // 1. 设置断点（通过ptrace或mprotect+软件断点）
    // 2. 在断点处触发信号
    // 3. 在信号处理程序中修改上下文
    
    target_function(123);
    
    return 0;
}
```

## 六、方法五：使用 `LD_PRELOAD` 进行运行时劫持

这是最实用的生产级方法：

### hook.c
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <stdlib.h>

// 要拦截的函数类型
typedef int (*orig_func_type)(int, int);

// 原始函数指针
static orig_func_type orig_func = NULL;

// 我们的钩子函数
int hooked_function(int a, int b) {
    printf("[HOOK] Before: args = %d, %d\n", a, b);
    
    // 修改参数
    a += 100;
    b += 200;
    
    // 获取原始函数（延迟绑定）
    if (!orig_func) {
        orig_func = (orig_func_type)dlsym(RTLD_NEXT, "target_function");
        if (!orig_func) {
            fprintf(stderr, "Error: %s\n", dlerror());
            exit(1);
        }
    }
    
    // 调用原始函数
    int result = orig_func(a, b);
    
    // 修改返回值
    result *= 10;
    
    printf("[HOOK] After: result = %d\n", result);
    return result;
}

// 如果目标函数有多个，可以使用弱符号
__attribute__((weak)) int target_function(int a, int b) {
    // 这只是一个占位符，实际会被LD_PRELOAD替换
    printf("Default implementation\n");
    return 0;
}

// 使用构造函数在main之前设置
__attribute__((constructor)) void init_hook() {
    printf("Hook library loaded!\n");
}
```

### target.c（目标程序）
```c
#include <stdio.h>

// 目标函数
int target_function(int a, int b) {
    printf("Original: %d + %d = ", a, b);
    int result = a + b;
    printf("%d\n", result);
    return result;
}

int main() {
    printf("Calling target_function:\n");
    int r = target_function(5, 3);
    printf("Main got: %d\n", r);
    return 0;
}
```

### 编译和运行
```bash
# 编译目标程序
gcc -fPIC -c target.c -o target.o
gcc target.o -o target -ldl

# 编译钩子库
gcc -fPIC -shared -o libhook.so hook.c -ldl

# 使用钩子运行
LD_PRELOAD=./libhook.so ./target
```

## 七、方法六：使用 `ptrace` 系统调用

```c
#include <stdio.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <unistd.h>
#include <stdlib.h>

// ptrace 示例 - 需要跟踪子进程
void trace_and_modify(pid_t child_pid) {
    int status;
    struct user_regs_struct regs;
    
    // 等待子进程停止
    waitpid(child_pid, &status, 0);
    
    // 设置选项
    ptrace(PTRACE_SETOPTIONS, child_pid, 0, PTRACE_O_TRACESYSGOOD);
    
    while(1) {
        // 单步执行
        ptrace(PTRACE_SINGLESTEP, child_pid, 0, 0);
        waitpid(child_pid, &status, 0);
        
        if (WIFEXITED(status)) {
            break;
        }
        
        // 获取寄存器
        ptrace(PTRACE_GETREGS, child_pid, 0, &regs);
        
        // 检查是否在目标函数中
        // 这里需要知道目标函数的地址
        // 可以解析/proc/pid/maps和ELF符号
        
        // 修改寄存器（参数/返回值）
        if (/* 在目标函数入口 */) {
            regs.rdi = 999;  // 修改第一个参数
            ptrace(PTRACE_SETREGS, child_pid, 0, &regs);
        }
        
        if (/* 在目标函数出口 */) {
            regs.rax = 8888;  // 修改返回值（x86-64）
            ptrace(PTRACE_SETREGS, child_pid, 0, &regs);
        }
    }
}

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {  // 子进程
        // 允许跟踪
        ptrace(PTRACE_TRACEME, 0, NULL, NULL);
        
        // 执行目标程序
        execl("./target", "target", NULL);
    } else {  // 父进程
        trace_and_modify(pid);
    }
    
    return 0;
}
```

## 八、安全注意事项

1. **栈破坏风险**：直接修改栈帧可能导致程序崩溃
2. **调用约定**：x86-64、x86、ARM等架构调用约定不同
3. **编译器优化**：`-O2`、`-O3`可能改变栈布局
4. **多线程安全**：修改全局状态可能导致竞争条件
5. **信号安全**：在信号处理程序中修改上下文需小心

## 九、生产环境建议

1. **优先使用`LD_PRELOAD`**：最安全、跨平台
2. **考虑使用现有工具**：
   - **Frida**：动态插桩框架
   - **DynamoRIO**：动态二进制插桩平台
   - **Pin**：Intel的插桩框架
3. **仅在调试/逆向工程中使用底层方法**

## 十、实际应用场景

1. **性能分析**：记录函数调用次数、耗时
2. **调试**：注入日志、断言
3. **安全测试**：模糊测试、漏洞检测
4. **热修复**：运行时打补丁
5. **API监控**：记录系统调用
