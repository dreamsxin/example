# 让函数运行在自己创建的栈上

每个程序都有独立的地址空间，他们被成为虚拟地址，经过转换后会得到实际的物理地址。
我们运行一个程序时，操作系统会为该程序创建独立的虚拟地址空间，并将程序的代码部分存放在其虚拟地址空间中。

接下来，一个程序还需要使用栈，因此操作系统再将程序所在的虚拟地址空间的一段地址映射到物理地址上，用来当作程序的栈。程序还有一些其他的段，例如用于存放常量的段、存放各种全局变量的段等。其均为程序在加载时就创建好的。

在我们的程序运行时，我们只能读写那些已经映射到物理地址上的地址，当我们尝试去读写没有映射到物理地址的虚拟地址时会引发错误。而申请内存的原理也是将一段虚拟地址映射到物理地址上并将这段虚拟地址返回给程序使用。

进程的内存结构由低地址到高地址分布如下

- 代码段（text）：就是C程序编译后的机器指令，也就是我们常见的汇编代码。
- 数据段（data）：存放显式初始化的全局变量或者静态（全局）变量，常量数据。
- BSS段（Block Started by Symbol): 存储未初始化的全局变量或者静态（全局）变量。编译器给处理成0；
- 堆段（heap): 动态内存分配的区域，也就是malloc申请的内存区，使⽤free()函数来释放内存（增长方向为高地址）
- 未使用内存
- 栈段(stack)：存放函数调⽤相关的参数、局部变量的值，以及在任务切换的上下⽂信息。栈区是由操作系统分配和管理的区域。（增长方向为低地址）

## C语言程序是如何访问栈的

当程序被加载好后，操作系统还需要将 `SP/ESP/RSP` 寄存器指向先前创建的栈的最高地址处。为什么是最高地址呢，因为当我们向栈中压入数据时，栈是向低地址方向增长的。

例如，假设一开始 `ESP` 寄存器指向了 `0x7C00`，当我们向栈中压入一个4字节的整数后，ESP 寄存器就会指向 `0x7BFC`

另外，栈指针寄存器一般总是指向栈顶的，也就是自 ESP 指向的内存开始向内存地址增大方向，均属于程序的栈。而C语言为了更方便维护栈的结构，以及为了方便调试，使用 `BP/EBP/RBP` (帧指针寄存器)来保存栈底的地址。因此在，一个函数用到的栈是从 ESP 寄存器到 EBP 寄存器之间的区域，这个区域称作栈帧。

当C语言程序进入一个新的函数时，先通过让 `EBP=ESP` 的操作让 EBP 寄存器指向新函数栈的栈底，再减少 `ESP` 寄存器（扩大栈）来为该函数分配所需的栈帧。而退出函数时只需要执行 `ESP=EBP` 将该函数所使用的栈帧清空，再将 EBP 恢复为执行该函数前的值，此时由 ESP 与 EBP 构成的区域就再次恢复到调用该函数之前的栈帧了。关于EBP的值如何恢复，只需要在修改其值之前将其压入栈即可。

由此可见，想要改变函数执行时使用的栈，只需要修改`ESP`和`EBP`，让其指向自己分配的内存，就可以实现切换栈的操作。而修改寄存器，需要通过汇编语言来完成。

## 接下来简单的介绍几个简单的汇编指令

- MOV ESP,EBP;将EBP的值复制到ESP中
- MOV ESP,[EBX];将EBP指向的内存中的值复制到ESP中

完成切换栈的操作，只需要了解 mov 指令即可。

## 使用自己创建的栈

要自己创建栈，需要有一段内存，因此需要先申请一段内存

        
```c
char *new_stack = (char*)malloc(1024*1024*10);//分配10MB的空间
```

这样我们就有了10MB的空间，将其作为栈了

接下来只需要将ESP指向申请到的这段空间的末尾即可，因为栈是向低地址方向增长的\

        
```c
new_stack += 1024*1024*10;//让指针指向栈的结尾
__asm 
{
    MOV ESP,new_stack; //将 new_stack 的值复制给ESP
}
```
在此之后调用新的函数等操作，就会在新的栈里了完成了。

但是，在新的栈里执行完后，可能还需要切换回原来的栈。这个操作并不能借助局部变量完成，因为一旦切换了栈，原来的局部变量就不再可用，但我们可以借助全局变量完成。以下给出完整的切换栈的操作。
```c
#include <stdio.h>
#include <stdlib.h>
void* old_stack;
void func()
{
	//在使用Windows系统默认的栈时会发生栈溢出，但在新的栈中不会
	char arr[1024 * 1024 * 9] = { 0 };
}
int main()
{
	char* new_stack = (char*)malloc(1024 * 1024 * 10);
	new_stack += 1024 * 1024 * 10;
	__asm
	{
		MOV old_stack, ESP; 备份当前栈
		MOV ESP, new_stack;切换到新栈
	}
	func();//在新的栈中执行该函数
	__asm
	{
		MOV ESP, old_stack;还原旧的栈
	}
	return 0;
}
```
