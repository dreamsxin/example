# JWT Token 黑名单控制方案

## 1. 概述

本文档描述了使用 Redis 实现 JWT Token 黑名单控制的方案。该方案通过在 Redis 中存储被撤销的 Token 记录（黑名单），并利用 Redis 的自动过期功能，使仍处于有效期的 JWT Token 能够被主动失效，从而增强系统安全性。

## 2. 核心概念

### 2.1 JWT (JSON Web Token)
- **定义**: 一种用于身份验证和授权的开放标准（RFC 7519）
- **结构**: 包含三个部分：Header（头部）、Payload（载荷）、Signature（签名）
- **特点**: Token 本身包含过期时间（exp 声明），但在过期时间内无法被主动撤销

### 2.2 黑名单机制
- **目的**: 存储已被管理员或系统主动撤销但尚未过期的 Token
- **工作流程**: 在每次 Token 验证时，检查该 Token 是否存在于黑名单中
- **清理机制**: 黑名单记录会在对应 Token 过期后自动从 Redis 中删除

## 3. 架构设计

### 3.1 存储策略
- **主要存储**: 使用 Redis 存储黑名单，利用其 TTL（生存时间）功能实现自动过期
- **辅助存储**: 使用 Redis 存储用户 Token 版本号，用于批量失效场景

### 3.2 核心验证流程
```
1. 接收用户请求，提取 JWT Token
2. 验证 Token 签名和基本有效性
3. 检查 Token 是否在黑名单中
   - 如果在黑名单中：拒绝访问，返回 401 状态码
   - 如果不在黑名单中：继续验证用户 Token 版本（如适用）
4. 执行业务逻辑处理
```

## 4. 实现方案

### 4.1 黑名单存储设计

#### 4.1.1 单 Token 黑名单记录
```redis
# Key 格式: jwt:blacklist:{token_hash}
# Value: 1（占位符，表示已列入黑名单）
# TTL: 设置为该 Token 的剩余有效时间
SETEX jwt:blacklist:md5(token) {remaining_ttl} 1
```

#### 4.1.2 用户 Token 版本控制
```redis
# Key 格式: jwt:version:user:{user_id}
# Value: 版本号（整数或时间戳）
# TTL: 设置为用户最长会话时间或固定值
SETEX jwt:version:user:12345 {ttl} {version}
```

### 4.2 Token 验证流程增强

1. **基础验证**: 验证 JWT 签名、有效期、发行者等标准声明
2. **黑名单检查**: 计算 Token 哈希值，查询 Redis 中是否存在对应黑名单记录
3. **版本验证**: 从 Token 中解析用户ID和版本号，与 Redis 中存储的当前版本比对
4. **决策**:
   - 若在黑名单中：拒绝访问
   - 若版本不匹配：拒绝访问
   - 否则：允许访问

## 5. 使用场景

### 5.1 用户主动登出
- **场景**: 用户主动退出登录，需要立即使当前使用的 Token 失效
- **实现步骤**:
  1. 计算当前 Token 的哈希值
  2. 将其加入 Redis 黑名单，TTL 设置为 Token 剩余有效期
  3. 客户端清除本地存储的 Token
  4. （可选）记录用户登出审计日志

### 5.2 管理员强制下线
- **场景**: 管理员发现异常操作或安全威胁，需要强制特定用户立即下线
- **实现步骤**:
  1. 更新该用户的 Token 版本号（使其所有 Token 失效）
  2. （可选）查询并批量将该用户的所有活跃 Token 加入黑名单
  3. 发送实时通知给客户端要求重新登录（通过 WebSocket 等）
  4. 记录安全审计日志，包括操作者、目标用户、原因等

### 5.3 密码重置后失效所有 Token
- **场景**: 用户修改密码后，所有已发放的 Token 应自动失效
- **实现步骤**:
  1. 更新用户的 Token 版本号（推荐）
  2. 或将该用户的所有活跃 Token 加入黑名单
  3. 发送安全通知给用户，提示密码已修改
  4. 允许用户在新设备上使用新 Token 登录

### 5.4 设备丢失/被盗
- **场景**: 用户设备丢失或被盗，需要远程使该设备上的 Token 失效
- **实现步骤**:
  1. 用户通过其他可信设备登录系统
  2. 在设备管理页面标记丢失设备
  3. 将该设备相关的所有 Token 加入黑名单
  4. （可选）提供设备管理功能，允许用户查看和管理所有登录设备

## 6. 安全考虑

### 6.1 访问控制与防滥用
- **操作权限**: 仅允许授权用户或管理员执行黑名单操作
- **频率限制**: 对同一用户/IP的频繁黑名单操作实施限制
- **审计日志**: 记录所有黑名单操作（操作者、时间、目标、原因）
- **API防护**: 在 API 网关或应用层实施速率限制，防止恶意请求

### 6.2 Token 哈希算法
- **推荐算法**: SHA-256（平衡性能与安全性）
- **哈希输入**: Token 字符串本身，或结合用户ID降低碰撞风险
- **注意**: MD5 仅适用于内部哈希场景，不适用于加密需求

### 6.3 性能优化
- **Redis部署**: 采用集群模式确保高可用和扩展性
- **内存管理**:
  - 使用 Token 哈希值而非完整 Token 存储，节省内存
  - 定期扫描并清理已过期但仍存在的黑名单记录（作为保险机制）
- **连接管理**: 合理配置 Redis 连接池参数，避免连接泄露
- **监控指标**:
  - Redis 内存使用率、命中率、响应时间
  - 黑名单操作成功率与延迟
  - 黑名单查询频率与分布

## 7. 故障处理与降级策略

### 7.1 Redis 不可用时的降级方案

#### 方案一：本地缓存降级（推荐）
- **实施**: 当 Redis 不可用时，切换到本地内存缓存（如 Guava Cache）
- **特点**: 黑名单功能仍部分可用，但无法在集群间同步
- **适用**: 短时间故障，且应用允许短暂的数据不一致

#### 方案二：拒绝服务（安全优先）
- **实施**: 当 Redis 不可用时，拒绝所有需要黑名单验证的请求
- **特点**: 保证安全性，但影响可用性
- **适用**: 对安全要求极高的场景

#### 方案三：白名单模式降级
- **实施**: 维护一个核心用户/管理员的白名单，仅对白名单用户进行严格验证
- **特点**: 平衡安全与可用性
- **适用**: 故障期间需要保证核心功能可用

#### 方案四：短期记忆降级
- **实施**: 应用本地记录近期已撤销的 Token（如最近5分钟）
- **特点**: 防止故障期间立即发生的恶意重复使用
- **适用**: 短暂故障，且 Token 有效期较短

#### 方案五：基于时间的降级
- **实施**: 临时放宽验证，如仅验证 Token 签名，不检查黑名单
- **特点**: 最大程度保证可用性，但安全风险最高
- **适用**: 内部低风险系统或紧急情况

### 7.2 恢复策略

1. **监控告警**:
   - 实时监控 Redis 连接状态和性能指标
   - 降级模式触发时立即发送告警通知运维团队
   - 记录降级期间的访问日志供后续审计

2. **故障恢复**:
   - Redis 恢复后，逐步同步本地缓存中的黑名单记录
   - 验证数据一致性后，切换回正常验证模式
   - 分析故障原因，优化系统防止同类问题

3. **数据一致性保障**:
   - 降级期间记录所有黑名单操作日志
   - 恢复后根据日志重建黑名单状态
   - 提供工具验证和修复数据不一致情况

## 8. 扩展建议

### 8.1 多维度黑名单
- 支持按用户、设备、IP等多维度管理黑名单
- 提供灵活的查询和管理接口

### 8.2 实时通知机制
- 集成消息队列，实时通知相关服务 Token 失效事件
- 支持 WebSocket 向客户端推送强制下线通知

### 8.3 监控与报表
- 提供黑名单使用情况统计报表
- 监控异常登录和 Token 撤销模式
- 集成安全信息和事件管理（SIEM）系统
