## 调用
https://wiki.mozilla.org/Education/Learning/UsingXpcom#Using_nsICookieManager_in_C.2B.2B
- `xpcom\components\nsServiceManagerUtils.h`
do_GetService
- `xpcom\base\nsCOMPtr.h`

```shell
about:debugging
about:config
```

## 签名

- `toolkit\mozapps\extensions\internal\XPIInstall.sys.mjs`
```js
export var verifyBundleSignedState = async function (aBundle, aAddon) {
  let pkg = Package.get(aBundle);
  try {
    let { signedState, signedTypes } = await pkg.verifySignedState(
      aAddon.id,
      aAddon.type,
      aAddon.location
    );
    return { signedState, signedTypes };
  } finally {
    pkg.close();
  }
};
```
- `toolkit\mozapps\extensions\AddonManager.sys.mjs`
```js
  // Constants for Addon.signedState. Any states that should cause an add-on
  // to be unusable in builds that require signing should have negative values.
  // Add-on signing is not required, e.g. because the pref is disabled.
  SIGNEDSTATE_NOT_REQUIRED: undefined,
  // Add-on is signed but signature verification has failed.
  SIGNEDSTATE_BROKEN: -2,
  // Add-on may be signed but by an certificate that doesn't chain to our
  // our trusted certificate.
  SIGNEDSTATE_UNKNOWN: -1,
  // Add-on is unsigned.
  SIGNEDSTATE_MISSING: 0,
  // Add-on is preliminarily reviewed.
  SIGNEDSTATE_PRELIMINARY: 1,
  // Add-on is fully reviewed.
  SIGNEDSTATE_SIGNED: 2,
  // Add-on is system add-on.
  SIGNEDSTATE_SYSTEM: 3,
  // Add-on is signed with a "Mozilla Extensions" certificate
  SIGNEDSTATE_PRIVILEGED: 4,
```
- `toolkit\mozapps\extensions\content\aboutaddons.js`
- `toolkit\mozapps\extensions\test\browser\head.js`
`isCorrectlySigned`

### Using nsICookieManager in C++
```cpp
#include "nsICookieManager.h"
...
nsresult rv;
nsCOMPtr<nsICookieManager> cookieManager = do_GetService(NS_COOKIEMANAGER_CONTRACTID, &rv);
NS_ENSURE_SUCCESS(rv, rv);
...
cookieManager->RemoveAll();
```
**nsCOMPtr**
```cpp
nsCOMPtr<nsICookieManager> cookieManager = do_GetService(NS_COOKIEMANAGER_CONTRACTID);
if (cookieManager)
{
  nsCOMPtr<nsICookieManager2> cookieManager2 = do_QueryInterface(cookieManager);
  if (cookieManager2)
  {
   ...
  }
}
```
**Services**
```cpp
nsCOMPtr<nsIServiceManager> servMan;
nsresult rv = NS_GetServiceManager(getter_AddRefs(servMan));
if (NS_FAILED(rv))
  return -1;

nsCOMPtr<nsICookieManager> cookieManager;
rv = servMan->GetServiceByContractID("@mozilla.org/cookiemanager",
                                     NS_GET_IID(nsICookieManager),
                                     getter_AddRefs(cookieManager));

if (NS_FAILED(rv))
  return -1;
```
```cpp
nsCOMPtr<nsICookieManager> cookieManager = do_GetService(NS_COOKIEMANAGER_CONTRACTID);
if (cookieManager)
{
  ...
}
```
### Using nsICookieManger in JavaScript
```js
var cookieManager = Components.classes["@mozilla.org/cookiemanager;1"]
                              .getService(Components.interfaces.nsICookieManager);
cookieManager.removeAll();
```
```js
var cookieManager = Components.classes["@mozilla.org/cookiemanager;1"].getService();
cookieManager = cookieManager.QueryInterface(Components.interfaces.nsICookieManager);
```

`xpinstall.signatures.required`
## 配置保存位置
Roaming
`C:\Users\Administrator\AppData\Roaming\Mozilla\Firefox\Profiles\0d5p49u6.default-default-2\extensions.json`

# profile

- extensions.json
- addonStartup.json.lz4 

## autoconfiglocal.js
```conf
defaultPref("extensions.enabledAddons", "SimpleX%40White.Theme:3.0");
```

## prefs.js
extensions.enabledAddons / extensions.enabledItems)

Something like:
```conf
user_pref("extensions.enabledAddons", "extId1:version,extId2:version");
user_pref("extensions.enabledAddons", "{972ce4c6-7e08-4474-a285-3208198ce6fd}:11.0");
user_pref("extensions.enabledAddons", "meek-http-helper@bamsoftware.com:1.0");
```


##

```js
      addonFile = new FileUtils.File(addonPath);
      addon = await AddonManager.installTemporaryAddon(addonFile);
```
### `\toolkit\mozapps\extensions`
- AddonManager
- AddonManagerInternal
```js
  ({ AddonManager, AddonManagerPrivate } = ChromeUtils.importESModule(
    "resource://gre/modules/AddonManager.sys.mjs"
  ));
```
- AddonManager.installAddonFromWebpage
- AddonManagerPrivate.registerProvider(this, Array.from(ALL_XPI_TYPES));
- XPIProvider
```js
  async getAddonsByTypes(aTypes) {
    if (aTypes && !aTypes.some(type => ALL_XPI_TYPES.has(type))) {
      return [];
    }
    return XPIExports.XPIDatabase.getAddonsByTypes(aTypes);
  },
```
- GMPProvider
- SitePermsAddonProvider

### `toolkit\mozapps\extensions\internal`
- const PREF_INSTALL_REQUIRESECUREORIGIN = "extensions.install.requireSecureOrigin";
- const PREF_PENDING_OPERATIONS = "extensions.pendingOperations";
- const PREF_SYSTEM_ADDON_UPDATE_URL = "extensions.systemAddon.update.url";
- const PREF_XPI_ENABLED = "xpinstall.enabled";
- const PREF_XPI_DIRECT_WHITELISTED = "xpinstall.whitelist.directRequest";
- const PREF_XPI_FILE_WHITELISTED = "xpinstall.whitelist.fileRequest";
- const PREF_XPI_WHITELIST_REQUIRED = "xpinstall.whitelist.required";
- const PREF_XPI_WEAK_SIGNATURES_ALLOWED = "xpinstall.signatures.weakSignaturesTemporarilyAllowed";
- const PREF_SELECTED_THEME = "extensions.activeThemeID";

- XPIExports

```js
const ALL_XPI_TYPES = new Set(["dictionary", "extension", "locale", "theme"]);

const DIR_EXTENSIONS = "extensions";
const DIR_SYSTEM_ADDONS = "features";
const DIR_APP_SYSTEM_PROFILE = "system-extensions";
const DIR_STAGE = "staged";
const DIR_TRASH = "trash";

const FILE_XPI_STATES = "addonStartup.json.lz4";

const KEY_PROFILEDIR = "ProfD";
const KEY_ADDON_APP_DIR = "XREAddonAppDir";
const KEY_APP_DISTRIBUTION = "XREAppDist";
const KEY_APP_FEATURES = "XREAppFeat";

const KEY_APP_PROFILE = "app-profile";
const KEY_APP_SYSTEM_PROFILE = "app-system-profile";
const KEY_APP_SYSTEM_ADDONS = "app-system-addons";
const KEY_APP_SYSTEM_DEFAULTS = "app-system-defaults";
const KEY_APP_BUILTINS = "app-builtin";
const KEY_APP_GLOBAL = "app-global";
const KEY_APP_SYSTEM_LOCAL = "app-system-local";
const KEY_APP_SYSTEM_SHARE = "app-system-share";
const KEY_APP_SYSTEM_USER = "app-system-user";
const KEY_APP_TEMPORARY = "app-temporary";
```

- XPIInstall
- AddonInstall
- LocalAddonInstall
- DownloadAddonInstall
```js
  async getInstallForURL(aUrl, aOptions) {
    let locationName = aOptions.useSystemLocation
      ? XPIExports.XPIInternal.KEY_APP_SYSTEM_PROFILE
      : XPIExports.XPIInternal.KEY_APP_PROFILE;
    let location = XPIExports.XPIInternal.XPIStates.getLocation(locationName);
    if (!location) {
      throw Components.Exception(
        "Invalid location name",
        Cr.NS_ERROR_INVALID_ARG
      );
    }

    let url = Services.io.newURI(aUrl);

    if (url instanceof Ci.nsIFileURL) {
      let install = new LocalAddonInstall(location, url, aOptions);
      await install.init();
      return install.wrapper;
    }

    let install = new DownloadAddonInstall(location, url, aOptions);
    return install.wrapper;
  },

/**
 * Creates a new AddonInstall to install an add-on from a local file.
 *
 * @param {nsIFile} file
 *        The file to install
 * @param {XPIStateLocation} location
 *        The location to install to
 * @param {Object?} [telemetryInfo]
 *        An optional object which provides details about the installation source
 *        included in the addon manager telemetry events.
 * @returns {Promise<AddonInstall>}
 *        A Promise that resolves with the new install object.
 */
function createLocalInstall(file, location, telemetryInfo) {
  if (!location) {
    location = XPIExports.XPIInternal.XPIStates.getLocation(
      XPIExports.XPIInternal.KEY_APP_PROFILE
    );
  }
  let url = Services.io.newFileURI(file);

  try {
    let install = new LocalAddonInstall(location, url, { telemetryInfo });
    return install.init().then(() => install);
  } catch (e) {
    logger.error("Error creating install", e);
    return Promise.resolve(null);
  }
}

/**
 * Uninstall an addon from a location.  This allows removing non-visible
 * addons, such as system addon upgrades, when a higher precedence addon
 * is installed.
 *
 * @param {string} addonID
 *        ID of the addon being removed.
 * @param {XPIStateLocation} location
 *        The location to remove the addon from.
 */
async function uninstallAddonFromLocation(addonID, location) {
  let existing = await XPIExports.XPIDatabase.getAddonInLocation(
    addonID,
    location.name
  );
  if (!existing) {
    return;
  }
  if (existing.active) {
    let a = await AddonManager.getAddonByID(addonID);
    if (a) {
      await a.uninstall();
    }
  } else {
    XPIExports.XPIDatabase.removeAddonMetadata(existing);
    location.removeAddon(addonID);
    XPIExports.XPIInternal.XPIStates.save();
    AddonManagerPrivate.callAddonListeners("onUninstalled", existing);
  }
}
```
- DirectoryLocation
- DirectoryInstaller::installAddon
- SystemAddonLocation
- SystemAddonInstaller::installAddon
## 配置

- const PREF_BLOCKLIST_PINGCOUNTVERSION = "extensions.blocklist.pingCountVersion";
- const PREF_EM_UPDATE_ENABLED = "extensions.update.enabled";
- const PREF_EM_LAST_APP_VERSION = "extensions.lastAppVersion";
- const PREF_EM_LAST_PLATFORM_VERSION = "extensions.lastPlatformVersion";
- const PREF_EM_AUTOUPDATE_DEFAULT = "extensions.update.autoUpdateDefault";
- const PREF_EM_STRICT_COMPATIBILITY = "extensions.strictCompatibility";
- const PREF_EM_CHECK_UPDATE_SECURITY = "extensions.checkUpdateSecurity";
- const PREF_SYS_ADDON_UPDATE_ENABLED = "extensions.systemAddon.update.enabled";
- const PREF_REMOTESETTINGS_DISABLED = "extensions.remoteSettings.disabled";
- const PREF_USE_REMOTE = "extensions.webextensions.remote";

`extensions.webextensions.addons-restricted-domains@mozilla.com.disabled`
`extensions.quarantinedDomains.enabled`
