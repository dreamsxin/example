# 字符串

字符串有两种基本的存储格式:
- `8-bit code unit (byte/char)` 字符串
- `16-bit code unit (PRUnichar)` 字符串
所有带大写C开头的字符串类都是 8-bit 的. 当然所有不含大写C开头的字符串类都是16字节的。

`8-bit` 的字符串可以使用N多编码，但是16-bit的字符串永远都是使用UTF-16编码。最常见的编码格式如下：
- ASCII - 8-bit encoding for basic English-only strings.
内部使用，一般采用这种格式
- UCS2 - 16-bit encoding for a subset of Unicode, BMP.
- UTF-8 - 8-bit encoding for Unicode characters. 
- UTF-16 - 16-bit encoding for Unicode storage, backwards compatible with UCS2.

## `xpcom\string\nsCharTraits.h`
```c++
template <class CharT>
struct nsCharTraits {};

template <>
struct nsCharTraits<char16_t> {
  typedef char16_t char_type;
  typedef uint16_t unsigned_char_type;
  typedef char incompatible_char_type;

  static char_type* const sEmptyBuffer;

  static char_type* copyASCII(char_type* aStr1, const char* aStr2, size_t aN) {
    for (char_type* s = aStr1; aN--; ++s, ++aStr2) {
      NS_ASSERTION(!(*aStr2 & ~0x7F), "Unexpected non-ASCII character");
      *s = static_cast<char_type>(*aStr2);
    }
    return aStr1;
  }
}
```
## `xpcom\string\nsTStringRepr.h`
nsTStringRepr 定义了字符串的内存布局和一些访问器方法。此类上的所有方法都必须是 const。
```c++
template <typename T>
class nsTStringRepr {
  typedef T char_type;

  typedef nsTStringRepr<T> self_type;
  typedef self_type base_string_type;

  char_type* mData;
  LengthStorage mLength;
  DataFlags mDataFlags;
  ClassFlags const mClassFlags;

 protected:
  nsTStringRepr() = delete;  // Never instantiate directly

  constexpr nsTStringRepr(char_type* aData, size_type aLength,
                          DataFlags aDataFlags, ClassFlags aClassFlags)
      : mData(aData),
        mLength(aLength),
        mDataFlags(aDataFlags),
        mClassFlags(aClassFlags) {}
}
```
## `xpcom\string\nsTSubstringTuple.h`
表示字符串片段的元组。构建为递归二叉树。它用于实现两个或多个字符串 `nsTStringRepr` 对象的连接。
```c++
template <typename T>
class MOZ_TEMPORARY_CLASS nsTSubstringTuple {
 public:
  nsTSubstringTuple(const base_string_type* aStrA,
                    const base_string_type* aStrB)
      : mHead(nullptr), mFragA(aStrA), mFragB(aStrB) {}

  nsTSubstringTuple(const self_type& aHead, const base_string_type* aStrB)
      : mHead(&aHead),
        mFragA(nullptr),  // this fragment is ignored when aHead != nullptr
        mFragB(aStrB) {}

 private:
  const self_type* const mHead;
  const base_string_type* const mFragA;
  const base_string_type* const mFragB;
}
```
## `xpcom\string\nsTSubstring.h`
nsTSubstring 是一个抽象字符串类。从 API 的角度来看，这个类是字符串类层次结构的根。实现各类 `Assign` 成员函数。它表示一个连续的字符数组，可以以 null 结尾，也可以不以 null 结尾。
此类型不直接实例化。取而代之的是实例化一个子类。例如，请参见 `nsTString`。
```c++
template <typename T>
class nsTSubstring : public mozilla::detail::nsTStringRepr<T> {
}
```

## `xpcom\string\nsTString.h`
以 `null` 结尾的字符串类。所有子类都承诺以 `null` 结尾的存储。此类的实例在堆上分配字符串。
```c++
template <typename T>
class nsTString : public nsTSubstring<T> {
 public:
  typedef nsTString<T> self_type;
}
```

## `xpcom\string\nsTLiteralString.h`
存储以 `null` 结尾、不可变的字符序列。
`nsTString` 相似，可以隐式转换为 `const nsTString& `， `const`是必需的，因为此类的数据不可写。这个类没有析构函数。
```c++
template <typename T>
class nsTLiteralString : public mozilla::detail::nsTStringRepr<T> {
  typedef nsTLiteralString<T> self_type;

  /**
   * constructor
   */

  template <size_type N>
  explicit constexpr nsTLiteralString(const char_type (&aStr)[N])
      : nsTLiteralString(aStr, N - 1) {}

  nsTLiteralString(const nsTLiteralString&) = default;

  /**
   * For compatibility with existing code that requires const ns[C]String*.
   * Use sparingly. If possible, rewrite code to use const ns[C]String&
   * and the implicit cast will just work.
   */
  const nsTString<T>& AsString() const MOZ_LIFETIME_BOUND {
    return *reinterpret_cast<const nsTString<T>*>(this);
  }
}
```
## `xpcom\string\nsStringFwd.h`

- using nsAString = nsTSubstring<char16_t>;
- using nsSubstringTuple = nsTSubstringTuple<char16_t>;
- using nsString = nsTString<char16_t>;
- using nsAutoString = nsTAutoString<char16_t>;
- using nsAutoStringN = nsTAutoStringN<char16_t, N>;
- using nsDependentString = nsTDependentString<char16_t>;
- using nsDependentSubstring = nsTDependentSubstring<char16_t>;
- using nsPromiseFlatString = nsTPromiseFlatString<char16_t>;
- using nsStringComparator = nsTStringComparator<char16_t>;
- using nsLiteralString = nsTLiteralString<char16_t>;
- using nsSubstringSplitter = nsTSubstringSplitter<char16_t>;

## 编码转码

### UTF-8 / UTF-16 conversion

- NS_ConvertUTF8toUTF16(const nsACString&)
- NS_ConvertUTF8toUTF16(utf8String).get()
`UTF-16` 转为 `UTF-8`，使用 `.get` 获得 `const char* buffer`
- NS_ConvertUTF16toUTF8(const nsAString&)
- NS_ConvertUTF16toUTF8(utf16String).get()
- CopyUTF8toUTF16(const nsACString& mLocalUTF8Value, nsAString& result))
`UTF-8` 拷贝覆盖 `UTF-16`
- CopyUTF16toUTF8(const nsAString&, nsACString&)

- AppendUTF8toUTF16(const nsACString&, nsAString&)
- AppendUTF16toUTF8(const nsAString&, nsACString&)
`UTF-8` 拷贝追加 `UTF-16`

- UTF8ToNewUnicode(const nsACString&, PRUint32* aUTF16Count = nsnull)
- ToNewUTF8String(const nsAString&)

### char* / char16_t*
```c++
nsAutoCString cstr(str.c_str());
NS_ConvertUTF8toUTF16 acstr(cstr);
const char16_t* x= acstr.get();
```

### 有损转换
一般用于原始字符串为 `ASCII` 格式。
UTF-16 to ASCII converters
- NS_LossyConvertUTF16toASCII(nsAString)
- LossyCopyUTF16toASCII(nsAString, nsACString)
- LossyAppendUTF16toASCII(nsAString, nsACString)
- ToNewCString(nsAString)
ASCII to UTF-16 converters
- NS_ConvertASCIItoUTF16(nsACString)
- CopyASCIItoUTF16(nsACString, nsAString)
- AppendASCIItoUTF16(nsACString, nsAString)
- ToNewUnicode(nsACString)

## Literal Strings
原始字符串转换
- NS_LITERAL_CSTRING(literal string)
- NS_NAMED_LITERAL_CSTRING(variable, literal string)
- NS_LITERAL_STRING(literal string)
- NS_NAMED_LITERAL_STRING(variable,literal string) 

## Mozilla Framework Based on Templates

- `mfbt\ToString.h`
- `dist\include\mozilla\ToString.h`

https://firefox-source-docs.mozilla.org/xpcom/stringguide.html

所有的字符串类都是从 `nsAString/nsACString` 这两个抽象基类派生。

| 宽                 | 窄                  |
|-------------------|--------------------|
| nsAString         | nsACString         |
| nsString          | nsCString          |
| nsAutoString      | nsAutoCString      |
| nsDependentString | nsDependentCString |

- nsAString/nsACString: 所有字符串类的基类，定义了xpcom中字符串的基本操作，如赋值、字符存取、基本的字符操作，比较等。nsAString 可以不必是以null（\0）结尾的。（nsAString is not necessarily null-terminated.）
```c++
nsAutoCString cstr("test");
```
- nsString/nsCString: 从以上两个基类继承而来，可以保证字符串是以null结尾。这两个类允许通过get()方法获取c风格的字符串（以'\0'结尾的字符数组）。
```c++
nsString outFilePath;
outFilePath.Assign(basePath);
outFilePath.AppendLiteral("update.json");

ToString(outFilePath).c_str();
```
以为所有的字符串类都是从两个基类继承而来的，因为它们共享一些基本的API接口，如一些简单的只读函数：
.Length() - 字符串字符数目 (对于窄字符串类字符是char对于宽字节来说是PRUnichar)。
.IsEmpty() - 最快的可以判断字符串为空的方法. 用这个方法来代替 string.Length == 0
.Equals(string) - 判定两个字符串内容相同.

一些简单的改变字符串的方法：
.Assign(string) - 用string的值给字符串赋值.
.Append(string) - 追加string到字符串.
.Insert(string, position) - 在给定位置（position）的字符前插入string.
.Truncate(length) - 将字符串缩短到length指定的长度.

- char*
Raw character pointer to ASCII (7-bit) string, no string classes used.
- char16_t*
Raw character pointer to UTF-16 string, no string classes used.
- nsAString
UTF-16 string.
- nsACString
8-bit string
```c++
inline std::string ToString(const nsACString& text) {
  return {text.BeginReading(), text.Length()};
}

nsAutoString partitionKey;
partitionKey.AssignASCII(v.value().c_str());
NS_ConvertUTF16toUTF8(partitionKey);
```
- nsCString
```c++
nsCString(value.value().c_str())
```
```c++
#include "nsString.h"
#include "nsCString.h"
#include "nsAutoString.h"
#include "nsAutoCString.h"
#include "nsDependentString.h"
#include "nsDependentCString.h"

void Example() {
    // nsString to char*
    nsString nsStr = NS_LITERAL_STRING("Hello, Unicode!");
    nsCString nsCStr;
    nsCStr.Append(nsStr);
    const char* charPtr = nsCStr.get();

    // char* to nsString
    const char* charStr = "Hello, ASCII!";
    nsString nsStr2;
    nsStr2.InitWithCString(charStr);

    // nsCString to char*
    nsCString nsCStr2 = NS_LITERAL_CSTRING("Hello, ASCII!");
    const char* charPtr2 = nsCStr2.get();

    // char* to nsCString
    const char* charStr2 = "Hello, ASCII!";
    nsCString nsCStr3;
    nsCStr3.InitWithCString(charStr2);

    // nsAutoString to char*
    nsAutoString nsAutoStr = NS_LITERAL_STRING("Hello, Unicode!");
    nsAutoCString nsAutoCStr;
    nsAutoCStr.Append(nsAutoStr);
    const char* charPtr3 = nsAutoCStr.get();

    // char* to nsAutoString
    const char* charStr3 = "Hello, ASCII!";
    nsAutoString nsAutoStr2;
    nsAutoStr2.InitWithCString(charStr3);

    // nsDependentString to char*
    const char* externalStr = "Hello, Unicode!";
    nsDependentString nsDepStr(externalStr, strlen(externalStr));
    nsDependentCString nsDepCStr;
    nsDepCStr.Append(nsDepStr);
    const char* charPtr4 = nsDepCStr.get();

    // char* to nsDependentString
    const char* charStr4 = "Hello, ASCII!";
    nsDependentCString nsDepCStr2(charStr4, strlen(charStr4));
    nsDependentString nsDepStr2(nsDepCStr2);
}
```
